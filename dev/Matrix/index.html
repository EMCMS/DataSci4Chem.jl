<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Matrix manipulation · DataSci4Chem.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DataSci4Chem.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataSci4Chem.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Basics/">Basics</a></li><li><a class="tocitem" href="../vis/">Data visualization</a></li><li class="is-active"><a class="tocitem" href>Matrix manipulation</a><ul class="internal"><li><a class="tocitem" href="#Matrix-dimensionality"><span>Matrix dimensionality</span></a></li><li><a class="tocitem" href="#Matrix-operations"><span>Matrix operations</span></a></li><li><a class="tocitem" href="#Matrix-decomposition"><span>Matrix decomposition</span></a></li></ul></li><li><a class="tocitem" href="../svd/">SVD</a></li><li><a class="tocitem" href="../RootFinding/">Numerical root finding</a></li><li><a class="tocitem" href="../Integration/">Numerical integration</a></li><li><a class="tocitem" href="../fit/">Curve fitting</a></li><li><a class="tocitem" href="../DataExplore/">Data exploration</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Matrix manipulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Matrix manipulation</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EMCMS/DataSci4Chem.jl/blob/main/docs/src/Matrix.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Matrix-Manipulation"><a class="docs-heading-anchor" href="#Matrix-Manipulation">Matrix Manipulation</a><a id="Matrix-Manipulation-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-Manipulation" title="Permalink"></a></h1><p><a href="https://en.wikipedia.org/wiki/Matrix_(mathematics)">Matrices</a> are multi-dimensional data containers, which have very important properties enabling a branch of mathematics called <a href="https://en.wikipedia.org/wiki/Linear_algebra">Linear Algebra</a>. Matrices can have multiple dimensions. However, the most commonly used type is a two dimensional matrix (e.g. <em><span>$X_{m,n}$</span></em>) or <em><span>$m \times n$</span></em>. The first dimension of a matrix (i.e. <em>m</em>) is the number of rows and the second dimension (i.e. <em>n</em>) is the number of columns of that matrix. A matrix with one of dimensions being <strong>one</strong> is called a <a href="https://en.wikipedia.org/wiki/Vector_(mathematics_and_physics)">vector</a>. Matrices may contain one or multiple data types, including mixed data types (e.g. combination of strings and integers). A matrix with multiple type data is called an <a href="https://en.wikipedia.org/wiki/Array_(data_structure)">Array</a> while the homogeneous data container is a matrix. This module only focuses on the homogeneous matrices containing only numerical entries, given their mathematical properties. </p><h2 id="Matrix-dimensionality"><a class="docs-heading-anchor" href="#Matrix-dimensionality">Matrix dimensionality</a><a id="Matrix-dimensionality-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-dimensionality" title="Permalink"></a></h2><p>The very first step to be able to work with matrices is being able to handle them, including being able to select specific rows, columns, and/or entries in a matrix. As mentioned before each entry in a matrix has its own coordinates (i.e. the row and column number). For example, the <span>$a_{2,1}$</span> represents the entry on the second row and the first column. </p><p class="math-container">\[
A_{m,n} = 
\begin{pmatrix}
a_{1,1} &amp; a_{1,2} &amp; \cdots &amp; a_{1,n} \\
a_{2,1} &amp; a_{2,2} &amp; \cdots &amp; a_{2,n} \\
\vdots  &amp; \vdots  &amp; \ddots &amp; \vdots  \\
a_{m,1} &amp; a_{m,2} &amp; \cdots &amp; a_{m,n} 
\end{pmatrix}
\]</p><h3 id="Entry-selection"><a class="docs-heading-anchor" href="#Entry-selection">Entry selection</a><a id="Entry-selection-1"></a><a class="docs-heading-anchor-permalink" href="#Entry-selection" title="Permalink"></a></h3><p>In julia to select an entry of a matrix you can use &quot;<em>[m,n]</em>&quot;, where <em>m</em> is the row number and <em>n</em> is the column number. It should be noted that these numbers are also referred to as indices. In the below example we first generate a matrix of 15 by 20 filled by random numbers, which will be used for our examples.</p><pre><code class="language-julia hljs">using DataSci4Chem

# Generating the data

m = 15          # number of rows
n = 21          # number of columns

X = randn(m,n)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">15×21 Matrix{Float64}:
  0.296691   -2.11141   -0.0446689  …  -1.31216      0.659868   0.0495847
 -3.05345    -0.854951   0.281738      -0.750222     2.15404    1.22526
 -0.52081    -0.178712   1.58094        0.33002      0.501392  -2.19278
 -0.871494    1.33629    0.876702       1.45621     -0.68594    1.12954
 -2.67621    -0.773182   0.425777      -1.06839     -0.854595   1.01778
 -0.203614    0.719043   0.652893   …  -0.523877     0.767159  -0.505919
 -0.624628    1.10036    0.638976      -0.711941     2.18424   -1.10901
 -0.43625    -0.500182   0.61011       -0.940807    -0.821244  -0.443892
  0.0249608   0.278511  -0.550956       1.35967      0.283526   1.43019
  0.252657   -0.801354   0.242369       0.226181    -0.990946   0.89057
  0.219886    1.28453    1.66771    …   1.34632     -1.43906    0.205862
 -1.30092     1.96883    0.0707041     -0.98939      0.483581  -2.67689
  2.07448     1.57744    0.339438       0.283317     0.526872   0.140244
  1.42264    -0.115862  -0.699063       0.00205772   0.542922  -0.0368221
 -0.341057   -0.869215  -0.0313992      1.96805     -1.52173    0.544468</code></pre><p>As you can see, we have generated our matrix of random <a href="https://en.wikipedia.org/wiki/Double-precision_floating-point_format">floats</a> and have stored it in a variable called <em>X</em>. Now as our first example we will attempt at selecting the matrix entry at the row 5 and column 20. To do that we use the provided coordinates with &quot;[]&quot;. Here we first select the specified entry and store it in the variable &quot;x1&quot; and then printed. </p><pre><code class="language-julia hljs">using DataSci4Chem

x1 = X[5,20]

println(x1)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.8545954312739152</code></pre><p>We can also select more than one entry at a time. For example if we want to select the entries between 3rd and 10th rows on the 2nd column we take advantage of ranges (i.e. 3:10). Similar to the single entry selection we put the relevant range in the spot for rows and select the column #2. </p><pre><code class="language-julia hljs">using DataSci4Chem

x2 = X[3:10,2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">8-element Vector{Float64}:
 -0.17871209770595295
  1.3362852944732464
 -0.7731817884926483
  0.7190432322833058
  1.1003567837086015
 -0.5001822087516692
  0.2785113480347545
 -0.8013539808078594</code></pre><p>As you can see, the output of this operation is a matrix of 8 by 1, thus a vector of 8 elements. We can perform the range selection in both row and column level at the same time. The example below shows how to select rows 5:10 and columns 1:3. This should result into a 6 by 3 matrix. </p><pre><code class="language-julia hljs">using DataSci4Chem

X1 = X[5:10,1:3]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">6×3 Matrix{Float64}:
 -2.67621    -0.773182   0.425777
 -0.203614    0.719043   0.652893
 -0.624628    1.10036    0.638976
 -0.43625    -0.500182   0.61011
  0.0249608   0.278511  -0.550956
  0.252657   -0.801354   0.242369</code></pre><p>There are also cases where you would like to select a column or an entire row in a matrix. In this case also we can use ranges expressed by &quot;:&quot;. Since this is the full range from 1:end you do not need to specify the details. For example for selecting the second column of the <em>X</em> we can use the expression <em>X[:,2]</em>, which implies that we are selecting all the rows in the second column. </p><pre><code class="language-julia hljs">using DataSci4Chem

X2 = X[:,2]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">15-element Vector{Float64}:
 -2.1114130526099624
 -0.8549508072623151
 -0.17871209770595295
  1.3362852944732464
 -0.7731817884926483
  0.7190432322833058
  1.1003567837086015
 -0.5001822087516692
  0.2785113480347545
 -0.8013539808078594
  1.2845296769566612
  1.968828949074604
  1.5774396002939413
 -0.11586188437414419
 -0.8692153329680598</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Please note that as a generally accepted rule, the matrices and vectors are represented with CAPITAL letters (e.g. <em>X</em>) while the entries are represented with small letters (e.g. <em>x</em>). </p></div></div><p>You can also select multiple columns or rows of a matrix. In this example we are selecting rows 3:5 of the matrix <em>X</em>. </p><pre><code class="language-julia hljs">using DataSci4Chem

X3 = X[3:5,:]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×21 Matrix{Float64}:
 -0.52081   -0.178712  1.58094   -0.944158  …   0.33002   0.501392  -2.19278
 -0.871494   1.33629   0.876702   0.599054      1.45621  -0.68594    1.12954
 -2.67621   -0.773182  0.425777  -0.809638     -1.06839  -0.854595   1.01778</code></pre><p>So far we have selected rows and/or columns that are next to each other, thus accessible with ranges. We can also access entries in a matrix that are not next to one another. In the below example we are selecting the columns 1, 3, and 21 of the matrix <em>X</em>. For this we need to generate a vector of the column indices (i.e. [1,3,21]), which is used for our operation. </p><pre><code class="language-julia hljs">using DataSci4Chem

X4 = X[:,[1,3,21]]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">15×3 Matrix{Float64}:
  0.296691   -0.0446689   0.0495847
 -3.05345     0.281738    1.22526
 -0.52081     1.58094    -2.19278
 -0.871494    0.876702    1.12954
 -2.67621     0.425777    1.01778
 -0.203614    0.652893   -0.505919
 -0.624628    0.638976   -1.10901
 -0.43625     0.61011    -0.443892
  0.0249608  -0.550956    1.43019
  0.252657    0.242369    0.89057
  0.219886    1.66771     0.205862
 -1.30092     0.0707041  -2.67689
  2.07448     0.339438    0.140244
  1.42264    -0.699063   -0.0368221
 -0.341057   -0.0313992   0.544468</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When setting indices for a matrix or a dataframe, you must work with <a href="https://en.wikipedia.org/wiki/Integer">integers</a> that are larger than zero or <a href="https://en.wikipedia.org/wiki/Boolean_data_type">boolians</a>. </p></div></div><p>Now that we know how to select entries or chunks of a matrix, we can start working on matrix operations. </p><h2 id="Matrix-operations"><a class="docs-heading-anchor" href="#Matrix-operations">Matrix operations</a><a id="Matrix-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-operations" title="Permalink"></a></h2><h3 id="Element-wise"><a class="docs-heading-anchor" href="#Element-wise">Element wise</a><a id="Element-wise-1"></a><a class="docs-heading-anchor-permalink" href="#Element-wise" title="Permalink"></a></h3><p>Most matrix operations are divided into two categories: element wise and the matrix wise. For the element vise operations the two matrices must have exactly the same size as the desired operation is performed element by element. Consequently, the resulting matrix will have the same size as the starting matrices. </p><h4 id="Summation"><a class="docs-heading-anchor" href="#Summation">Summation</a><a id="Summation-1"></a><a class="docs-heading-anchor-permalink" href="#Summation" title="Permalink"></a></h4><p>An example of such operations is summing or subtracting two matrices. Let&#39;s generate two matrices 4 by 5 populated with random numbers called <em>A</em> and <em>B</em>. </p><pre><code class="language-julia hljs">using DataSci4Chem

A = rand(4,5)

B = rand(4,5)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×5 Matrix{Float64}:
 0.45342   0.344934  0.411503  0.138598  0.766777
 0.129689  0.79647   0.972665  0.663614  0.620017
 0.258159  0.499271  0.457526  0.153456  0.920863
 0.383287  0.174677  0.359753  0.481623  0.361268</code></pre><p>Now we can try to sum up these two matrices and store the results in the matrix <em>C</em>. </p><pre><code class="language-julia hljs">using DataSci4Chem

C = A + B</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×5 Matrix{Float64}:
 0.502558  0.983988  0.495951  0.184344  1.25909
 0.806975  1.64121   1.18093   1.20905   1.38654
 1.04003   0.834296  0.522345  0.394896  1.38694
 0.998585  0.381202  0.524811  0.57768   1.21516</code></pre><p>The matrix <em>D</em> is the result of subtraction of two matrices <em>A</em> and <em>B</em>. </p><pre><code class="language-julia hljs">using DataSci4Chem

D = A - B</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">4×5 Matrix{Float64}:
 -0.404282   0.294119   -0.327054  -0.0928516  -0.274462
  0.547598   0.0482724  -0.764403  -0.118176    0.146502
  0.523713  -0.164246   -0.392706   0.0879837  -0.454788
  0.232012   0.031848   -0.194695  -0.385566    0.492621</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>The operation summation has the commutative and associative properties. In other words the following is correct: </p><ol><li><em>A</em> + <em>B</em> = <em>B</em> + <em>A</em> (commutative),</li><li>(<em>A</em> + <em>B</em>) + <em>C</em> = <em>A</em> + (<em>B</em> + <em>C</em>) (associative).</li></ol></div></div><h4 id="Transpose"><a class="docs-heading-anchor" href="#Transpose">Transpose</a><a id="Transpose-1"></a><a class="docs-heading-anchor-permalink" href="#Transpose" title="Permalink"></a></h4><p>Another very useful element wise matrix operation is the &quot;transpose&quot; operation. When a matrix is transposed its rows and columns are switched. This means that if you have started with <em><span>$X2_{3,2}$</span></em>, you will end up with matrix <em><span>$X2^{T}_{2,3}$</span></em>. In the below example we have a 3 by 2 matrix <em>X2</em> and we will try to transpose it to <em>X2_t</em>. </p><pre><code class="language-julia hljs">using DataSci4Chem

X2 = [1 2 ; 4 3 ;  5 4]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Int64}:
 1  2
 4  3
 5  4</code></pre><pre><code class="language-julia hljs">using DataSci4Chem

X2_t = DataSci4Chem.transpose([1 2 ; 4 3 ;  5 4])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×3 transpose(::Matrix{Int64}) with eltype Int64:
 1  4  5
 2  3  4</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>A transposed matrix <em>X</em> is typically denoted as <em><span>$X^{T}$</span></em>  or <em><span>$X^{&#39;}$</span></em>. Within this documentation we will use the <em>X_t</em> for the code snippet.</p></div></div><h4 id="Scalar-multiplication"><a class="docs-heading-anchor" href="#Scalar-multiplication">Scalar multiplication</a><a id="Scalar-multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-multiplication" title="Permalink"></a></h4><p>Another element wise matrix operation is the multiplication of a <a href="https://en.wikipedia.org/wiki/Scalar_(mathematics)">scalar</a> (i.e. a number) to a matrix. Here the scalar is multiplied into each element individually, thus element wise. For example if we multiply the scalar 2 to the matrix <em>X2</em> we will get the following. </p><pre><code class="language-julia hljs">using DataSci4Chem

2 * X2</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Int64}:
  2  4
  8  6
 10  8</code></pre><h4 id="Element-wise-multiplication"><a class="docs-heading-anchor" href="#Element-wise-multiplication">Element wise multiplication</a><a id="Element-wise-multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Element-wise-multiplication" title="Permalink"></a></h4><p>The last element wise matrix operation that is discussed here is the element-wise matrix multiplication or <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">Hadamard product</a>. This operation is denoted as &quot;<span>$\odot$</span>&quot; and is performed using &quot;.*&quot; in julia language. </p><pre><code class="language-julia hljs">using DataSci4Chem

X2 .* (2 * ones(3,2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Float64}:
  2.0  4.0
  8.0  6.0
 10.0  8.0</code></pre><p>In the above example with the function <em>ones(3,2)</em> we are generating a 3 by 2 matrix of ones, which is multiplied by the scalar 2, resulting in a 3 by 2 matrix of twos. In the next step the two matrices are multiplied element wise. As you can intuitively imagine and combination of these three components will result in the same output. </p><pre><code class="language-julia hljs">using DataSci4Chem

2 * X2 .* ones(3,2)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Float64}:
  2.0  4.0
  8.0  6.0
 10.0  8.0</code></pre><p>or </p><pre><code class="language-julia hljs">using DataSci4Chem

2 * (X2 .* ones(3,2))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">3×2 Matrix{Float64}:
  2.0  4.0
  8.0  6.0
 10.0  8.0</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This can be done due to the <a href="https://en.wikipedia.org/wiki/Associative_property">associative</a> properties of the element wise matrix multiplication.</p></div></div><h3 id="Matrix-wise"><a class="docs-heading-anchor" href="#Matrix-wise">Matrix wise</a><a id="Matrix-wise-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-wise" title="Permalink"></a></h3><h4 id="Matrix-multiplication"><a class="docs-heading-anchor" href="#Matrix-multiplication">Matrix multiplication</a><a id="Matrix-multiplication-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-multiplication" title="Permalink"></a></h4><p>One of the most important matrix wise operations is the matrix multiplication. Let&#39;s say we have a matrix <em><span>$A_{m,p}$</span></em> and a second matrix <em><span>$B_{p,n}$</span></em> for these matrices to be multipliable they must have the same inner dimensions.</p><p class="math-container">\[
A_{m,p} \times B_{p,n} = C_{m,n}

\]</p><p>As you can see the result of this multiplication is a matrix <em><span>$C_{m,n}$</span></em>. Each entry in the product matrix is the result of first element-wise multiplication of the first matrix rows to the second matrix columns followed by summation of those products. This process can be described with the below formula. </p><p class="math-container">\[
i = 1:m, \\ j = 1:n, \\

c_{i,j} = \sum_{k=1}^{p} a_{i,k}b_{k,j}  

\]</p><p>Let&#39;s see this in practice: </p><p class="math-container">\[
A = 
\begin{pmatrix}
1 &amp; 6 \\
9 &amp; 3 
\end{pmatrix}

\\

and\\

B = 
\begin{pmatrix}
0 &amp; -1 \\
-1 &amp; 2 
\end{pmatrix}

\]</p><p>Based on the above formula the first entry of the <em><span>$c_{1,1}$</span></em> will be calculated as:</p><p class="math-container">\[

c_{1,1} = a_{1,1}b_{1,1} +  a_{1,2}b_{2,1} = 1 \times 0 + 6 \times -1 = -6  

\]</p><p>while the <em><span>$c_{1,2}$</span></em> is calculated a following.</p><p class="math-container">\[

c_{1,2} = a_{1,1}b_{1,2} +  a_{1,2}b_{2,2} = 1 \times -1 + 6 \times 2 = 11  

\]</p><p>Following this process we can calculate the product os <em>A</em> and <em>B</em>. </p><p class="math-container">\[
 
\begin{pmatrix}
1 &amp; 6 \\
9 &amp; 3 
\end{pmatrix}

\times
 
\begin{pmatrix}
0 &amp; -1 \\
-1 &amp; 2 
\end{pmatrix} = 

\begin{pmatrix}
-6 &amp; 11 \\
-3 &amp; -3 
\end{pmatrix}

\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This matrix multiplication has the following properties: </p><ol><li><span>$0 \times A = 0$</span>, <span>$A \times 0 = 0$</span> </li><li><span>$I \times A = A$</span>, <span>$A \times I = A$</span></li><li><span>$A(B + C) = AB + AC$</span>, <span>$(A + B)C = AC + BC$</span></li><li><span>$(A \times B)^{T} = A^{T} \times B^{T}$</span> </li></ol></div></div><h4 id="Matrix-powers"><a class="docs-heading-anchor" href="#Matrix-powers">Matrix powers</a><a id="Matrix-powers-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-powers" title="Permalink"></a></h4><p>Matrix power is an extension of the matrix multiplication where <em><span>$A^{n} = \prod_{i=1}^{n} A$</span></em>, which denotes n multiplications of the matrix <em>A</em>. However, it should be noted that this is only possible for square matrices as non-squared matrices cannot be multiplied by themselves. </p><h4 id="Inverse-matrix"><a class="docs-heading-anchor" href="#Inverse-matrix">Inverse matrix</a><a id="Inverse-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Inverse-matrix" title="Permalink"></a></h4><p>Calculation of the <a href="https://en.wikipedia.org/wiki/Invertible_matrix">inverse matrix</a> (i.e. <em><span>$A^{-1}$</span></em>) is one of the most fundamental operations that you will do with matrices. It has applications in regression, optimization, matrix decomposition and many other areas of scientific computing. For a matrix to be &quot;invertible&quot; (i.e. nonsingular), it has to satisfy two criteria: </p><ol><li>it must be square </li><li><em><span>$A^{-1} \times A = I$</span></em>. </li></ol><p>In fact for calculating the inverse of a matrix you can use the second criteria for invertible matrices. Let&#39;s look an example for this. </p><p class="math-container">\[
\begin{pmatrix}
a &amp; b \\
c &amp; d 
\end{pmatrix}

\times 

\begin{pmatrix}
1 &amp; -1 \\
1 &amp; 2 
\end{pmatrix}

= 

\begin{pmatrix}
1 &amp; 0 \\
0 &amp; 1 
\end{pmatrix}

\]</p><p>If we solve this problem we will end up with the below matrix. </p><p class="math-container">\[
\begin{pmatrix}
a &amp; b \\
c &amp; d 
\end{pmatrix}

\times 

\begin{pmatrix}
1 &amp; -1 \\
1 &amp; 2 
\end{pmatrix}

= 
\begin{pmatrix}
a+b &amp; 2b-a \\
c+d &amp; 2d-c 
\end{pmatrix}

=

\begin{pmatrix}
1 &amp; 0 \\
0 &amp; 1 
\end{pmatrix}

\]</p><p>Now we have a set of four equations and four variables that can be rewritten as a system of equations. </p><p class="math-container">\[
a + b = 1\\
2b - a = 0 \\
c + d = 1 \\
2d + c = 0 
\]</p><p>Solving these equations ultimately will result in the inverse matrix.</p><p class="math-container">\[
\begin{pmatrix}
1 &amp; -1 \\
1 &amp; 2 
\end{pmatrix}^{-1}

= 
\begin{pmatrix}
0.333 &amp; -0.333 \\
0.333 &amp; -0.666 
\end{pmatrix}

\]</p><p>You can calculate the inverse of invertible matrices using the functions <em>inv()</em> or <em>pinv(-)</em> (i.e. <a href="https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse">pseudo inverse</a>). </p><pre><code class="language-julia hljs">using DataSci4Chem

A = [2 1; -1 1]
inv(A)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">2×2 Matrix{Float64}:
 0.333333  -0.333333
 0.333333   0.666667</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>For a matrix <em>X</em>, which is not square, thus noninvertible, the <em><span>$X^{T}X$</span></em> matrix is square and has very special characteristics. </p></div></div><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The inverse matrix also has a lot of interesting properties: </p><ol><li><em><span>$(A^{-1})^{-1} = A$</span></em> </li><li><em><span>$(A^{T})^{-1} = (A^{-1})^{-T}$</span></em></li><li>if <em><span>$y = Ax$</span></em> where <em>x</em> <span>$\in R^{n}$</span> and <em>A</em> is invertible, then <em><span>$x = A^{-1} y$</span></em>. </li></ol></div></div><h2 id="Matrix-decomposition"><a class="docs-heading-anchor" href="#Matrix-decomposition">Matrix decomposition</a><a id="Matrix-decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-decomposition" title="Permalink"></a></h2><p><a href="https://en.wikipedia.org/wiki/Matrix_decomposition">Matrix decomposition</a> is another important operation where a matrix <em>X</em> is decomposed/factorized into product matrices. There are several matrix decomposition methods, depending on the applications. For example for solving systems of equations <a href="https://en.wikipedia.org/wiki/LU_decomposition">LU decomposition</a> is employed. One of the highly relevant matrix decomposition approaches is <a href="https://en.wikipedia.org/wiki/Singular_value_decomposition">singular value decomposition (SVD)</a>. The SVD decomposes a matrix <em>X</em> into the product is three matrices <em><span>$U_{m \times n}$</span></em>, <em><span>$D_{n \times n}$</span></em>, and <em><span>$V_{n \times n}^{T}$</span></em>. The matrix <em><span>$U_{m \times n}$</span></em> is the left singular matrix and it represents a rotation in the matrix space. The <em><span>$D_{n \times n}$</span></em> is diagonal matrix and contains the singular values. Finally, <em><span>$V_{n \times n}^{T}$</span></em> is called the right singular matrix and is associated with rotation. For more details of SVD please look at <a href="https://emcms.github.io/ACS.jl/dev/svd/">SVD course material</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../vis/">« Data visualization</a><a class="docs-footer-nextpage" href="../svd/">SVD »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 11 September 2023 14:53">Monday 11 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
