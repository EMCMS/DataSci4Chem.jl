<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SVD · DataSci4Chem.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="DataSci4Chem.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">DataSci4Chem.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../Basics/">Basics</a></li><li><a class="tocitem" href="../vis/">Data visualization</a></li><li><a class="tocitem" href="../Matrix/">Matrix manipulation</a></li><li class="is-active"><a class="tocitem" href>SVD</a><ul class="internal"><li><a class="tocitem" href="#Introduction"><span>Introduction</span></a></li><li><a class="tocitem" href="#Singular-Value-Decomposition-Theorem"><span>Singular Value Decomposition Theorem</span></a></li><li><a class="tocitem" href="#Doing-it-yourself"><span>Doing it yourself</span></a></li><li><a class="tocitem" href="#Applications"><span>Applications</span></a></li><li><a class="tocitem" href="#Further-reading"><span>Further reading</span></a></li></ul></li><li><a class="tocitem" href="../RootFinding/">Numerical root finding</a></li><li><a class="tocitem" href="../Integration/">Numerical integration</a></li><li><a class="tocitem" href="../fit/">Curve fitting</a></li><li><a class="tocitem" href="../DataExplore/">Data exploration</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SVD</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SVD</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/EMCMS/DataSci4Chem.jl/blob/main/docs/src/svd.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Singular-Value-Decomposition"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition">Singular Value Decomposition</a><a id="Singular-Value-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition" title="Permalink"></a></h1><h2 id="Introduction"><a class="docs-heading-anchor" href="#Introduction">Introduction</a><a id="Introduction-1"></a><a class="docs-heading-anchor-permalink" href="#Introduction" title="Permalink"></a></h2><p>In many cases, a data matrix can be very well approximated by a sum (&quot;linear combination&quot;) of products of vectors. As a trivial example, consider the matrix</p><p class="math-container">\[A = 
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 6 &amp; 9 \\
0 &amp; 0 &amp; 0 \\
2 &amp; 4 &amp; 6
\end{pmatrix}\]</p><p>Each row of this matrix is a multiple of the row vector <span>$`\begin{pmatrix} 1 &amp; 2 &amp; 3 \end{pmatrix}`$</span>, and in matrix notation we can write</p><p class="math-container">\[A = 
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 6 &amp; 9 \\
0 &amp; 0 &amp; 0 \\
2 &amp; 4 &amp; 6
\end{pmatrix}
=
\begin{pmatrix}
1\\3\\0\\2
\end{pmatrix}
\begin{pmatrix}
1 &amp; 2 &amp; 3
\end{pmatrix},\]</p><p>so in this case the &quot;sum of products of vectors&quot; is just one term. Here is a larger example: we measure the infrared spectra of 3000 samples and put them in matrix as rows. Each spectrum contains 2000 points, so the data is a 3000<span>$`\times`$</span>2000 matrix. To get a view of this rather large matrix we  translate numbers into color intensity, and we also make plots of the first five rows: <img src="https://github.com/EMCMS/DataSci4Chem.jl/blob/main/docs/src/assets/1component_example.png" alt="1component_example.png"/> It seems that here too, each row is a multiple of the same row vector (note that this will not be exactly so, because the noise on the data will not be the same in each row). The chemical interpretation of this fact is that apparently all the samples contain only one compound, but with different concentrations. To a good approximation we can write </p><p class="math-container">\[B = 
\begin{pmatrix}
c_1\\c_2\\\vdots\\c_{3000}
\end{pmatrix}
\begin{pmatrix}
p_1 &amp; p_2 &amp; \ldots &amp; p_{2000}
\end{pmatrix},\]</p><p>where the <span>$`c_i`$</span> values are (proportional to) the concentrations, and the vector <span>$`\begin{pmatrix} p_1 &amp; p_2 &amp; \ldots &amp; p_{2000} \end{pmatrix}`$</span> is the spectrum of the compound (=its absorption at 2000 different IR frequencies). Note that we need only 3000+2000 numbers to characterize the entire matrix, which contains 3000<span>$`\times`$</span>2000 numbers, so we have a data reduction by a factor of more than 1000. Of course, this situation will not occur very often. As a  more realistic example, here is a different set of IR spectra, again containing 2000 samples (=rows): <img src="https://github.com/EMCMS/DataSci4Chem.jl/blob/main/docs/src/assets/2component_example.png" alt="1component_example.png"/> Looking at the graphs of the first 5 rows, we see that this matrix can not be written as the product of two vectors: comparing the relative intensities at positions 1050 and 1720 of the blue and red data, it is clear that these two matrix rows are not multiples of each other (and therefore cannot be multiples of one and the same row vector). However, in this case, it turns out that the matrix can be very well approximated by a sum of two vector products:</p><p class="math-container">\[C = 
\begin{pmatrix}
c_{1,1}\\c_{2,1}\\\vdots\\c_{3000,1}
\end{pmatrix}
\begin{pmatrix}
p_{1,1} &amp; p_{1,2} &amp; \ldots &amp; p_{1,2000}
\end{pmatrix}+
\begin{pmatrix}
c_{1,2}\\c_{2,2}\\\vdots\\c_{3000,2}
\end{pmatrix}
\begin{pmatrix}
p_{2,1} &amp; p_{2,2} &amp; \ldots &amp; p_{2,2000}
\end{pmatrix}
,\]</p><p>where we needed an extra index for the <span>$c$</span> and <span>$s$</span> vectors since there are now two of each. The value <span>$`c_{i,j}`$</span> can be interpreted as the concentration of compound <span>$j$</span> in sample <span>$i$</span>, and the value <span>$`s_{i,j}`$</span> can be interpreted as the spectral absorption intensity of compound <span>$i$</span> at IR frequency <span>$j$</span>. This can be written more elegantly as a matrix product (and we can interpret the indices as matrix indices):</p><p class="math-container">\[C = 
\begin{pmatrix}
c_{1,1} &amp; c_{1,2}\\c_{2,1}&amp;c_{2,2}\\\vdots&amp;\vdots\\c_{3000,1}&amp; c_{3000,2}
\end{pmatrix}
\begin{pmatrix}
s_{1,1} &amp; s_{1,2} &amp; \ldots &amp; s_{2000,1}\\
s_{2,1} &amp; s_{2,2} &amp; \ldots &amp; s_{2000,2}
\end{pmatrix}\]</p><p>So in this case we need 2(3000+2000) numbers to characterize the matrix, still a huge reduction in data. This idea can be extended to sums of more than two products of vectors.</p><p>In many practical situations, matrices turn out to be such sums of a small number of vector products: in the case where the matrix contains sample spectra (IR, mass, NMR, ...), this is simply the mathematical expression of the fact that the samples contain a finite number of compounds, each with their own spectrum (but with different concentrations in the samples). However, when the number of components is larger than 1 it generally becomes difficult to find out how many there are by just looking at the data. For instance in the case of matrix <span>$`C`$</span> above, how did we know there were not more than 2 components required to describe it? (we will soon be able to answer this). Two questions naturally arise: (1) is there a mathematical way of estimating how many components there are present in a data matrix? and (2) can we quantify how well the sum of component products approximates the original data matrix?</p><h2 id="Singular-Value-Decomposition-Theorem"><a class="docs-heading-anchor" href="#Singular-Value-Decomposition-Theorem">Singular Value Decomposition Theorem</a><a id="Singular-Value-Decomposition-Theorem-1"></a><a class="docs-heading-anchor-permalink" href="#Singular-Value-Decomposition-Theorem" title="Permalink"></a></h2><p>Theorem: any <span>$`m \times n`$</span> matrix <span>$A$</span> (with <span>$`m\ge n`$</span>) can be decomposed as</p><p class="math-container">\[\begin{pmatrix}
~\\~\\~\\~~~~~~~~~~~~A~~~~~~~~~~~~\\~\\~\\~
\end{pmatrix}
=
\begin{pmatrix}
~\\~\\~\\~~~~~~~~~~~~U~~~~~~~~~~~~\\~\\~\\~
\end{pmatrix}
\begin{pmatrix}
s_1 &amp; &amp; &amp; \\ &amp; s_2 &amp; &amp; \\ &amp; &amp; \ddots &amp; \\ &amp; &amp; &amp; s_n
\end{pmatrix}
\begin{pmatrix}
  &amp; &amp; &amp; &amp; &amp; \\ &amp;  &amp; &amp; &amp; &amp; \\ &amp; &amp; &amp;  \!\!\!V^T   &amp; &amp; \\  &amp;&amp; &amp;  &amp; &amp; \\ &amp; &amp; &amp; &amp; &amp;
\end{pmatrix},\]</p><p>where the middle matrix <span>$`S`$</span> is a diagonal <span>$`n\times n`$</span>  matrix with positive or zero elements (the singular values, basically &quot;weights&quot;), <span>$U$</span> has the same dimensions as <span>$`A`$</span> and has columns that are orthonormal vectors, and <span>$V^T$</span> is a square <span>$`n\times n`$</span> matrix with rows that are orthonormal vectors. This latter orthogonal-vector property of the columns of <span>$U$</span> and the rows of <span>$V^T$</span> can be written explicitly as</p><p class="math-container">\[\sum_i U_{ij}U_{ik} = \delta_{jk}\\\]</p><p class="math-container">\[\sum_j V^T_{ij}V^T_{kj} = \delta_{ik} \]</p><p>If the <span>$`s_i`$</span> are sorted by order of decreasing value, this decomposition is unique (apart from forming linear combinations of columns of <span>$U$</span> and rows of <span>$V^T$</span> that have the same <span>$s_i$</span> values). The names <span>$`U,S,V^T`$</span> of the matrices in the product are standard. Note that the diagonal matrix <span>$`S`$</span> in the middle &quot;picks out&quot; columns from the left matrix and rows from the right matrix, and that we can also write the above decomposition as</p><p class="math-container">\[\begin{pmatrix}
~\\~\\~\\~~~~~~~~~~~~A~~~~~~~~~~~~\\~\\~\\~
\end{pmatrix}
= s_1
\begin{pmatrix}
u_{1,1}\\u_{2,1}\\ \vdots \\ u_{m,1}
\end{pmatrix}
\begin{pmatrix}
v_{1,1} &amp;v_{1,2} &amp; \ldots &amp; v_{1,n}  
\end{pmatrix}
+
s_2
\begin{pmatrix}
u_{1,2}\\u_{2,2}\\ \vdots \\ u_{m,2}
\end{pmatrix}
\begin{pmatrix}
v_{2,1} &amp;v_{2,2} &amp; \ldots &amp; v_{2,n}  
\end{pmatrix}
+\ldots+
s_n
\begin{pmatrix}
u_{1,n}\\u_{2,n}\\ \vdots \\ u_{m,n}
\end{pmatrix}
\begin{pmatrix}
v_{n,1} &amp;v_{n,2} &amp; \ldots &amp; v_{n,n}  
\end{pmatrix}\]</p><p>This shows that the example matrices <span>$`A,B,C`$</span> above were special cases in which the only nonzero <span>$`s_i`$</span> were the first (for <span>$`A`$</span> and <span>$`B`$</span>) and the first and second (for <span>$`C`$</span>).</p><h4 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h4><p>Specifically, for matrix <span>$A$</span> above we have</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 6 &amp; 9 \\
0 &amp; 0 &amp; 0 \\
2 &amp; 4 &amp; 6
\end{pmatrix} =
\begin{pmatrix}
  0.267 &amp;  0.951 &amp;  -0.153\\
 0.802 &amp; -0.132  &amp;  0.583\\
  0.0      &amp;  0.0     &amp;   0.0\\
 0.535 &amp; -0.278 &amp; -0.798
\end{pmatrix}
\begin{pmatrix}
14 &amp;  &amp;  \\
 &amp; 0 &amp;  \\
 &amp; &amp; 0
\end{pmatrix}
\begin{pmatrix}
1 &amp; 2 &amp; 3 \\
3 &amp; 6 &amp; 9 \\
0 &amp; 0 &amp; 0 \\
2 &amp; 4 &amp; 6
\end{pmatrix}
= 14 \begin{pmatrix}
  0.267 \\
 0.802 \\
  0.0  \\
 0.535
\end{pmatrix}
\begin{pmatrix}
1 &amp; 2 &amp; 3
\end{pmatrix}\]</p><p>For many (if not most) data matrices that one encounters in practice, it turns out that the first few weights <span>$`s_i`$</span> are much larger than all the others. This means that if we truncate the summation after a small number of terms, we still get a good approximation of the original matrix. How good?</p><h3 id="Matrix-approximation"><a class="docs-heading-anchor" href="#Matrix-approximation">Matrix approximation</a><a id="Matrix-approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-approximation" title="Permalink"></a></h3><h2 id="Doing-it-yourself"><a class="docs-heading-anchor" href="#Doing-it-yourself">Doing it yourself</a><a id="Doing-it-yourself-1"></a><a class="docs-heading-anchor-permalink" href="#Doing-it-yourself" title="Permalink"></a></h2><p>Julia has a function <span>$svd$</span> that returns the SVD of any matrix. This function can be loaded (together with many other matrix functions) with <span>$using LinearAlgebra$</span>.</p><pre><code class="language- hljs">A = [[1,3,0,2] [2,6,0,4] [3,9,0,6]]
F = svd(A)</code></pre><p>after which the matrices <span>$`U,S,V^T`$</span> are contained in <span>$F.U$</span>, <span>$F.S$</span> and <span>$F.Vt$</span> (the nontransposed matrix <span>$`V`$</span> is contained in <span>$F.V$</span>). The SVD is calculated numerically, and in the case of matrix <span>$`A`$</span> we run into the machine precision:</p><pre><code class="nohighlight hljs">julia&gt; F.S
3-element Vector{Float64}:
 14.0
  4.43199111387671e-16
  4.7982681877701203e-32</code></pre><h2 id="Applications"><a class="docs-heading-anchor" href="#Applications">Applications</a><a id="Applications-1"></a><a class="docs-heading-anchor-permalink" href="#Applications" title="Permalink"></a></h2><h3 id="Sets-of-sample-spectra"><a class="docs-heading-anchor" href="#Sets-of-sample-spectra">Sets of sample spectra</a><a id="Sets-of-sample-spectra-1"></a><a class="docs-heading-anchor-permalink" href="#Sets-of-sample-spectra" title="Permalink"></a></h3><h3 id="Chemical-Kinetics"><a class="docs-heading-anchor" href="#Chemical-Kinetics">Chemical Kinetics</a><a id="Chemical-Kinetics-1"></a><a class="docs-heading-anchor-permalink" href="#Chemical-Kinetics" title="Permalink"></a></h3><h3 id="Image-compression"><a class="docs-heading-anchor" href="#Image-compression">Image compression</a><a id="Image-compression-1"></a><a class="docs-heading-anchor-permalink" href="#Image-compression" title="Permalink"></a></h3><h2 id="Further-reading"><a class="docs-heading-anchor" href="#Further-reading">Further reading</a><a id="Further-reading-1"></a><a class="docs-heading-anchor-permalink" href="#Further-reading" title="Permalink"></a></h2><p><a href="https://sites.math.washington.edu/~morrow/464_16/svd.pdf">D. Kalman, &quot;A Singularly Valuable Decomposition: The SVD of a Matrix&quot;</a></p><p><a href="https://www.researchgate.net/publication/332751929">S. L. Brunton, &quot;Data Driven Science &amp; Engineering&quot;, chapter 1: Singular Value Decomposition</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Matrix/">« Matrix manipulation</a><a class="docs-footer-nextpage" href="../RootFinding/">Numerical root finding »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 11 September 2023 14:29">Monday 11 September 2023</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
