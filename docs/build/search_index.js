var documenterSearchIndex = {"docs":
[{"location":"vis/#Data-visualization-and-plotting","page":"Data visualization","title":"Data visualization and plotting","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Here we will explore basics of the data visualization from simple plots to model representations. The content of this section is mainly based on the Plots.jl package. You should be able to generate all the figures in this tutorial using the DataSci4Chem.jl package. For functions that are not exported directly, you can use DataSci4Chem.fun(-). ","category":"page"},{"location":"vis/#Simple-line-plot","page":"Data visualization","title":"Simple line plot","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"If you have one single variable as a vector of numbers, you can use simple line plot (plot). ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n# Generating the data\n\ny = collect(1:0.1:10)\n\n# Plotting the data\n\nplot(y)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Here we stored our vector of 100 entries between 0 and 10 in variable y. The \"x axis\" here represents the index of each value while the \"y axis\" is the assigned value of the y at each index. For example, if we multiply the y by a number (e.g. 5), the \"x axis\" will not change while the \"y axis\" will be adjusted. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\ny1 = 5 .* y\n\n# Plotting the data\n\nplot(y1)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"In this case the julia plotting backend is actually evaluating the below command to generate this figure. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\ny1 = 5 .* y\n\n# Plotting the data\n\nplot(1:length(y1),y1)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"The first entry in the plot(-) is replaced with a vector of indices from 1 to the length of the y. This implies that we generally need two variables of the same size to be able to use line plot. In case we have a x vector the above plot will be changed to the following. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nx = sin.(y)\n\n# Plotting the data\n\nplot(x,y)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"The x values in this plot are the sin(y) while the y values remain the same. ","category":"page"},{"location":"vis/#Frame","page":"Data visualization","title":"Frame","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can adjust different parameters associated with the plot axis such as axis labels and range. For doing so you can either modify an existing frame or set these parameters as attributes of plot(-). ","category":"page"},{"location":"vis/#Axis-label","page":"Data visualization","title":"Axis label","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Below you can see how the labels on the x and y axis are set via frame modification. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y)\nxlabel!(\"sin(y)\")              # setting the label of x axis \nylabel!(\"y values\")            # setting the label of the y axis\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can also set these parameters directly in the plot(-) function. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,xlabel=\"sin(y)\",ylabel=\"y values\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"These ways of setting axis labels can be used for any type of plot type as long as the generic \"GR\" backend is used. These approaches are not completely mapped for all the backends, particularly for PlotlyJS.  ","category":"page"},{"location":"vis/#Axis-limit","page":"Data visualization","title":"Axis limit","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can also set the range of each axis using the function lims!(-). This function must be adjusted for \"x axis\" vs \"y axis\". In other words for \"x axis\" it will become xlims!(-) while for the \"y axis\" it will be ylims!(-). ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,xlabel=\"sin(y)\",ylabel=\"y values\")\nxlims!(-2,2)                               # Setting the limits of x\nylims!(3,6)                                # Setting the limits of y\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Similar to the axis label, the same concept can be applied to any plot frame generated via Plots.jl. ","category":"page"},{"location":"vis/#Label/legend","page":"Data visualization","title":"Label/legend","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"When plotting multiple series or overlaying multiple frames, it is important to label each series accordingly. To do that we need to modify an attribute of the plot(-) called \"label\". If this parameter is not set, the series label is selected automatically to \"y1\". If you want to change this, you need to provide an input to the attribute \"label\" while plotting your data. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,xlabel=\"sin(y)\",ylabel=\"y values\",label = \"Example data\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"In case you want to remove the label of a data series, you can set the attribute label to false, which will result in the removal of the legend completely. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,xlabel=\"sin(y)\",ylabel=\"y values\",label = false)\n","category":"page"},{"location":"vis/#The-line-settings","page":"Data visualization","title":"The line settings","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"When plotting our data being able to adjust parameters associated with the line is very important. This becomes particularly important for the multivariate data. As a start we can change the line style with the keyword \"linestyle\", that is fed directly to the plot function. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,xlabel=\"sin(y)\",ylabel=\"y values\",label = false,linestyle=:dash)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"A shortcut to the \"linestyle\" parameter is \"ls\". In other words, you will get the same outcome replacing \"linestyle\" with \"ls\" in the above example. The GR backend in Plots.jl package has several builtin options for the line style. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"note: Note\nThe plotting backend in julia keeps the same the line style for all the plots unless it is specified. You need to set this parameter for each frame separately. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Another line setting to be adjusted is the line width, which helps with the visibility of the lines in your plot. The keyword for line width setting is \"linewidth\" or \"lw\". The parameter must be a real and positive number. For example by setting the \"lw\" to 2 for the above plot we can increase the visibility of our data. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,xlabel=\"sin(y)\",ylabel=\"y values\",label = false,linestyle=:dash,lw=2)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"For most figures, we also want to set the color of the lines in the plot, particularly when multiple lines are plotted. The parameter to be adjusted here is \"linecolor\" or \"lc\". The julia plotting backend, usually, sets a different color to each line in your plot. However, it is useful to be able to set these colors as it fits your needs. There several colors builtin the plots.jl and can be used without further definition. You can also set these colors manually via RGB cods. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,xlabel=\"sin(y)\",ylabel=\"y values\",label = false,\nlinestyle=:dash,lw=2,lc=:red)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"warning: Warning\nThere are other parameters that can be set related to the line style settings, which have not been discussed here. For a comprehensive list please refer to the \"Series Attributes\" page in Plots.jl documentation.   ","category":"page"},{"location":"vis/#Multiple-frames","page":"Data visualization","title":"Multiple frames","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"To plot multiple data series, there are two different options. These options are 1) using multivariate X and Y matrices or 2) overlay different frames on top of each other. ","category":"page"},{"location":"vis/#Multivariate-data-plotting","page":"Data visualization","title":"Multivariate data plotting","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"When providing multivariate matrices, julia treats each column in your data as a separate variable. This implies that for an X_2 times 10, two series are plotted. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx_m = hcat(x,x)\ny_m = hcat(y,y .+ 5)\n\nplot(x_m,y_m,xlabel=\"sin(y)\",ylabel=\"y values\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"In this case to add the legend to this plot you need to provide a vector of labels to the plot(-) function. The same goes for all the line setting attributes. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx_m = hcat(x,x)\ny_m = hcat(y,y .+ 5)\n\nplot(x_m,y_m,xlabel=\"sin(y)\",ylabel=\"y values\",label=[\"column 1\" \"column 2\"])\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"warning: Warning\nPlease note that the entries in the label vector are space separated. Otherwise, the backend will not be able to separate different entries from each other. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx_m = hcat(x,x)\ny_m = hcat(y,y .+ 5)\n\nplot(x_m,y_m,xlabel=\"sin(y)\",ylabel=\"y values\",label=[\"column 1\" \"column 2\"],\nlc = [:red :green], lw = [2 1], ls = [:dot :dash])\n","category":"page"},{"location":"vis/#Overlying-frames","page":"Data visualization","title":"Overlying frames","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Another option for plotting multivariate data is the use of overlying frames. For this you need to use the function plot!(-), which modifies the last in memory frame. To use this approach, you first plot your first variable and then overlay the additional variables on top of the already existing frame. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx_m = hcat(x,x)\ny_m = hcat(y,y .+ 5)\n\nplot(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 1\")\nplot!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 2\")\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"warning: Warning\nThe variable ranges, unless set, will take the values relevant to the largest frame. The labels must be set for each series separately to make sure proper display of the plots.","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"For setting the line attributes, you will have to set them up for each frame separately. Otherwise, julia will use the default settings. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx_m = hcat(x,x)\ny_m = hcat(y,y .+ 5)\n\nplot(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 1\",lw=2,ls=:dot,lc=:red)\nplot!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 2\",lw=1,ls=:dash)\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"For example, for the above plot in the second frame we do not set the \"lc\" parameter and as a consequence julia uses the default color sequence for the second line. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Another way to overlay the frames on top of each other is to store the frame information into a variable that can be retrieved and/or modified. For example, in the below case we are storing all the info of the first frame into variable \"p\". ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx_m = hcat(x,x)\ny_m = hcat(y,y .+ 5)\n\np = plot(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 1\",lw=2,ls=:dot,lc=:red)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"In the next step, one can modify this frame using the function plot!(-) by defining the first variable as the previous frame. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot!(p,x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",\nylabel=\"y values\",label=\"column 2\",lw=1,ls=:dash)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"tip: Tip\nThe same strategy can be used for updating the attributes of the plot.","category":"page"},{"location":"vis/#Plot-types","page":"Data visualization","title":"Plot types","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"There are several plot types implemented within the Plots.jl and accessible via DataSci4Chem.jl. Here we will discuss the most commonly used plot types. ","category":"page"},{"location":"vis/#Scatter","page":"Data visualization","title":"Scatter","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Scatter plots next to the line plots are one of the most commonly used plotting approaches. Similar to line plots, the inputs of scatter(-) are the matrics X and Y with the same size. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx_m = hcat(x,x)\ny_m = hcat(y,y .+ 5)\n\nscatter(x_m,y_m,xlabel=\"sin(y)\",ylabel=\"y values\",label=[\"column 1\" \"column 2\"])\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"tip: Tip\nAll the frame and axis related commands that work for line plots are applicable to scatter plots too.","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nscatter(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 1\",lw=2,ls=:dot,lc=:red)\nscatter!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 2\",lw=1,ls=:dash)\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"warning: Warning\nThe scatter plot ignores the parameters specific to line plots or other plot types (e.g. \"ls\"). For example, \"lc\", \"ls\", and \"lw\" parameters associated with line plots are skipped and the backend uses the default values for the scatter plot equivalent attribute. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"There are a few highly relevant attributes specific to scatter plots that will be discussed here. ","category":"page"},{"location":"vis/#Marker-properties","page":"Data visualization","title":"Marker properties","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can set both marker size, shape, color, and opacity for your scatter plots. These parameters will help readability of your figures and their interpretation. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"The default marker size is 4 and can be changed by resetting either \"markersize\" or \"ms\". For the \"ms\" please make sure to use a positive and real number. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nscatter(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 1\",ms=5)\nscatter!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 2\",ms=2)\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can also feed a vector of the size of \"Y\" to your marker size attribute. This will enable to plot higher dimensional data in a 2D plot. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nms1 = range(1, stop=10, length=size(y_m,1))\n\nscatter(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 1\",ms=ms1)\nscatter!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\",label=\"column 2\",ms=2)\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Another highly relevant scatter plot attribute is the marker shape, which is by default \"circle\" and can be changed using either \"markershape\" or \"shape\". For example if want to change the marker shape of column 2 in the above plot we can do this by doing the following. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nms1 = range(1, stop=10, length=size(y_m,1))\n\nscatter(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\"\n,label=\"column 1\",ms=ms1)\n\nscatter!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\"\n,label=\"column 2\",ms=2,shape=:+)\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"The marker color is the equivalent of \"lc\" attribute for the line plots. Similar to the \"lc\" you have access to the same color schemes via either \"markercolor\" or \"mc\".","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nms1 = range(1, stop=10, length=size(y_m,1))\n\nscatter(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\"\n,label=\"column 1\",ms=ms1)\n\nscatter!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\"\n,label=\"column 2\",ms=2,shape=:+,mc=:black)\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"The last scatter plot specific attribute discussed here is the marker opacity which is defined by \"markerapha\" or \"ma\". This attribute is very helpful with multiple frames' plots where a large amount of data is plotted. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nms1 = range(1, stop=10, length=size(y_m,1))\n\nscatter(x_m[:,1],y_m[:,1],xlabel=\"sin(y)\",ylabel=\"y values\"\n,label=\"column 1\",ms=ms1,ma=0.5)\n\nscatter!(x_m[:,2],y_m[:,2],xlabel=\"sin(y)\",ylabel=\"y values\"\n,label=\"column 2\",ms=3,shape=:+,mc=:black)\n\n","category":"page"},{"location":"vis/#Bar","page":"Data visualization","title":"Bar","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Another commonly used plotting style is bar plots. They are an easy way to get a quick overview of your data, particularly when your independent variable is discreet. However, care needs to be taken when scaling the data to avoid misleading conclusions. For example here we will plot the first 10 values of or first column. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nbar(x_m[:,1][1:10],y_m[:,1][1:10],label=\"column 1 - first 10\")\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Similar to the previous plot types we can add more frames to the existing figure to represent multiple data series. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nmeasles = [38556, 24472, 14556, 18060, 19549, 8122, 28541, 7880, 3283, 4135, 7953, 1884]\nmumps = [20178, 23536, 34561, 37395, 36072, 32237, 18597, 9408, 6005, 6268, 8963, 13882]\nchickenPox = [37140, 32169, 37533, 39103, 33244, 23269, 16737, 5411, 3435, 6052, 12825, 23332]\n\n\nbar(measles,label=\"measles\")\n\nbar!(mumps,label=\"mumps\")\n\nbar!(chickenPox,label=\"chickenPox\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"In the figure above each series is plotted on top of the previous one, which may not be the most desirable setup. To solve this issue we need to use a more complete backend/version of Plots.jl, which is StatsPlots.jl. The StatsPlots.jl has been exported as \"sp\" within the DataSci4Chem.jl package to avoid any conflicts with other packages. It can be accessed using the following syntax. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nsp.bar(measles,label=\"measles\")\n\nsp.bar!(mumps,label=\"mumps\")\n\nsp.bar!(chickenPox,label=\"chickenPox\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"For this case we need to used the function groupedbar(-) to be able to have the bars being plotted side by side. The combination of groupedbar(-) and the attribute \"bar_position\" enables having the bars side by side. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nsp.groupedbar([measles mumps chickenPox], bar_position = :dodge)\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"A variant of bar plot is histogram, which is very useful for exploring the distribution of the variables in a dataset. Histograms can be used for a first step during the data visualization. For example, when looking at the \"Iris\" dataset, we can explore the distribution of each variable via histograms. To import the data we are taking advantage of RDatasets.jl package. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\ndata = dataset(\"datasets\", \"iris\")     # Importing the data\ndescribe(data)                         # Summarizes the dataset\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Through the function describe(-) we can seen that the dataset contains five variables namely: sepal length, sepal width, petal length, petal width, and species. Now we can use histograms to explore the numerical variables. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nhistogram(data[!,\"SepalLength\"],label=false)\n\nxlabel!(\"SepalWidth\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"In this plot the bin size and number is set automatically by julia. However, the automatic choice may not be the best option for your case of data exploration. One of the parameters that can be set here is the number of bins. Let's change the number of bins to 20 instead of 8.","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nhistogram(data[!,\"SepalLength\"],label=false,bins =20)\n\nxlabel!(\"SepalWidth\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"warning: Warning\nAs you can see changing the number of bins may impact the final interpretation of your data. Therefore, you need to be sure that this parameter is adequately selected to correctly reflect the true distribution of your data. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Another way to change the number of bins or their size is to provide a vector of bins to the parameter \"bins\" rather than an integer. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nb_range = range(4, 8, length=21)                            # Generate the individual bins\n\nhistogram(data[!,\"SepalLength\"],label=false,bins =b_range)  # Use those bins for plotting the results\n\nxlabel!(\"SepalWidth\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Similar to the previous plots you can overlay multiple frames on top of each other. For example, below we are plotting the histogram of two separate variables in the \"iris dataset\" together. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nhistogram(data[!,\"SepalLength\"],label=\"Sepal Length\", bins=10)\nhistogram!(data[!,\"SepalWidth\"],label=\"Sepal Width\", bins=10)\n\nxlabel!(\"Bins\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"As you can see from the above plot the two distributions have an overlapping region, which is very difficult to see. To overcome this issue you can use the parameter \"fillalpha\", which sets the transparency of the bars. Please note that the order of the plotting is highly relevant when setting this parameter. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nhistogram(data[!,\"SepalLength\"],label=\"Sepal Length\", bins=10)\nhistogram!(data[!,\"SepalWidth\"],label=\"Sepal Width\", bins=10,fillalpha=0.6)\n\nxlabel!(\"Bins\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Another highly relevant parameter to adjust when using histograms is the normalization factor set via parameter \"norm\". The julia default is false (i.e. the pure count). This can be set to \":pdf\" resulting in the sum of areas will be set to one while :probability generates a plot where the sum of heights is equal to one. The normalization is very helpful when dealing with datasets with different population sizes. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nhistogram(data[!,\"SepalLength\"],label=\"Sepal Length\", bins=10,norm = :pdf)\nhistogram!(data[!,\"SepalWidth\"],label=\"Sepal Width\", bins=10,fillalpha=0.6, norm = :pdf)\n\nxlabel!(\"Bins\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"or ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nhistogram(data[!,\"SepalLength\"],label=\"Sepal Length\", bins=10,norm = :probability)\nhistogram!(data[!,\"SepalWidth\"],label=\"Sepal Width\", bins=10,fillalpha=0.6, norm = :probability)\n\nxlabel!(\"Bins\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/#Heatmap","page":"Data visualization","title":"Heatmap","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Heatmaps are a set of very information rich and versatile plots that can be used for multidimensional data plotting. In heatmaps the 3rd dimension is usually represented through a color scheme indicating the magnitude of the plotted data. Heatmaps either accept an D_mn or three variables where X_m1 and Y_1n. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nD = randn(10,20)\n\nheatmap(D)\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"or ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nx = range(5, 25, length=10) \ny = range(-5, 3, length=20) \n\nDataSci4Chem.heatmap(x,y,D)\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"When working with the heatmaps you can change the color scheme used via \"cmap\" and different colormaps. For example, below we are setting the colormap of our data to :jet.  ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nheatmap(x,y,D,cmap= :jet)\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"There are many useful attributes built in the heatmap function to enable you to visualize your data at best. Here we will discuss a few of those. ","category":"page"},{"location":"vis/#Color-scale-limits","page":"Data visualization","title":"Color scale limits","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can adjust the color scale in a similar way to the ranges of X and/or Y. For this you can use the attribute \"clim\". ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nheatmap(x,y,D,cmap= :turbo,clim=(-1,1))\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/#Colorbar-title","page":"Data visualization","title":"Colorbar title","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can also add a title to your colorbar as it represent highly relevant information. This can be done with \"colorbar_title\".","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nDataSci4Chem.heatmap(x,y,D,cmap= :turbo,clim=(-1,1),colorbar_title=\"My title\")\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/#Colorbar-position","page":"Data visualization","title":"Colorbar position","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can also set the position of the colorbar, depending on the backend, to improve the way that your data is displayed. For the position of the colorbar you can use the \"cbar\" attribute. The backend \"GR\" only supports absence and presence of the colorbar in the position of the legend. For example, below we are removing the colorbar completely.","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nheatmap(x,y,D,cmap= :turbo,clim=(-1,1),colorbar_title=\"My title\",cbar= :none)\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"tip: Tip\nThe plot type can be set as on the attributes of plot(-) using parameter \"seriestype\" or \"st\". In other words, you can use plot(-) for all the plot types presented above. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\nplot(data[!,\"SepalLength\"],label=\"Sepal Length\", st = :histogram,bins=10,norm = :probability)\nplot!(data[!,\"SepalWidth\"],label=\"Sepal Width\", st = :histogram, bins=10,fillalpha=0.6, norm = :probability)\n\nxlabel!(\"Bins\")\nylabel!(\"Frequency\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"or ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,D,st = :heatmap,cmap= :turbo,clim=(-1,1),colorbar_title=\"My title\")\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/#Advanced-topics","page":"Data visualization","title":"Advanced topics","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"This section aims at enabling you to generate publication quality figures. This is only a small selection of things that might be useful for high quality figure generation.","category":"page"},{"location":"vis/#Frame-size","page":"Data visualization","title":"Frame size","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"The size of the frame/plot can be set depending on the your needs. This is an attribute called \"size\", which is tuple and has (600,400) as default. For example, we can update the above plot by making it more square. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,D,st = :heatmap,cmap= :turbo,clim=(-1,1),colorbar_title=\"My title\",size=(600,600))\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/#The-figure-resolution","page":"Data visualization","title":"The figure resolution","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can also adjust the resolution of your plots using the attribute \"dpi\" (i.e. dots per inch). The higher is dpi the higher is the resolution and thus the quality of your plots. Julia sets this at 100 by default. For high quality figures using a value around 300 is recommended. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nplot(x,y,D,st = :heatmap,cmap= :turbo,clim=(-1,1),colorbar_title=\"My title\",size=(600,600),dpi =300)\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"note: Note\nWhen changing the dpi for a figure, you will not notice any differences at the screen level, given that the figure is rendered as a vector giving you the possibility to zoom in as much as possible. The dpi becomes very important when you are saving your plots.","category":"page"},{"location":"vis/#Subplots","page":"Data visualization","title":"Subplots","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"Subplots are the combination of multiple plots in separate sub-frames within on main frame. Subplots mainly use a combination of plot(-) and the attribute \"layout\" to achieve its goal. The simplest way of making subplots is the following. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\np1 = plot(x,y,D,st = :heatmap,cmap= :turbo,clim=(-1,1),colorbar_title=\"My title\")\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n\n\np2 = plot(data[!,\"SepalLength\"],label=\"Sepal Length\", st = :histogram,bins=10,norm = :probability)\n\nxlabel!(\"Bins\")\nylabel!(\"Frequency\")\n\nplot(p1,p2,layout = (1,2),size=(800,400))\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can also have a set of nested subplots to represent you data. Below you can see an example of such a case.   ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\np1 = plot(data[!,\"SepalWidth\"],label=\"SepalWidth\", st = :histogram,bins=10,norm = :probability)\n\nylabel!(\"Frequency\")\n\np2 = plot(data[!,\"SepalLength\"],label=\"Sepal Length\", st = :histogram,bins=10,norm = :probability)\n\nylabel!(\"Frequency\")\n\np3 = plot(x,y,D,st = :heatmap,cmap= :turbo,clim=(-1,1))\n\nxlabel!(\"Random values\")\nylabel!(\"Random values\")\n\n\n\nplot(plot(p1,p2),p3,layout = (2,1),margin = (5,:mm))\n\n\n","category":"page"},{"location":"vis/#Saving-figures","page":"Data visualization","title":"Saving figures","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"You can save your figures using the function savefig(-). This function takes the currently stored plot in the memory and saves it with a given title. You can also save a specific figure using its handle, if that figure is not the last figure stored in the memory. For example, here we are saving the last generated figure (i.e. the subplot). ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nsavefig(\"Example_fig.png\")\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"On the other hand, in this example we are saving the figure \"p3, which is the heatmap, independently from the last generated figure. ","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"using DataSci4Chem\n\n\nsavefig(p3,\"Example_fig_p3.png\")\n\n","category":"page"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"tip: Tip\nBy changing the extension of the figure in its name (i.e. \".png\" vs \".pdf\") you can change the format of the generated file as well as its quality. The extensions such as \".svg\", \".tiff\", and \".pdf\" tend to be of higher quality than \".png\" for example. ","category":"page"},{"location":"vis/#Additional-resources","page":"Data visualization","title":"Additional resources","text":"","category":"section"},{"location":"vis/","page":"Data visualization","title":"Data visualization","text":"There are several external resources for making plots and practicing. The main and the most important one is the Plots.jl documentation. There are several videos on YouTube with introductory lectures in julia plotting (https://www.youtube.com/watch?v=rtOqvqm5IjE).   ","category":"page"},{"location":"RootFinding/#Numerical-root-finding","page":"Numerical root finding","title":"Numerical root finding","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Root finding is the process of solving an equation for a specific variable. For example, the only root of f(x) = ax + b is the intersection between the f(x) and the x axis. In practice you are solving the below system of equations. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nf(x) = ax + b \nf(x) = 0 \n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"For simpler and low order equations the root finding can be performed in analytical manner while for complex systems numerical methods are utilized. Generally speaking, the numerical root finding methods are divided in four categories: bounded needing derivative (will not be discussed), unbounded with derivative, bounded without derivative, and those unbounded without derivative. Each of these methods have their own advantages and disadvantages.","category":"page"},{"location":"RootFinding/#Unbounded-with-derivative","page":"Numerical root finding","title":"Unbounded with derivative","text":"","category":"section"},{"location":"RootFinding/#Newton's-method","page":"Numerical root finding","title":"Newton's method","text":"","category":"section"},{"location":"RootFinding/#Theory","page":"Numerical root finding","title":"Theory","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"This strategy is one of the most commonly used approach to numerical root finding with Newton's method being the most well known of these methods. This is an iterative method where during the first iteration an initial guess x_0 for the potential root is made. Then both the f(x) and f'(x) are solved for x_0, which provides the intercept with the x axis. This value is assumed to be a better estimation of the root compared to the initial guess. Let's drive the Newton's method. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nf(x) = f(x)x + c\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Here f'(x) is the slope of the f(x) and c is the intercept. If we want to drive the equation of the tangent (i.e. slope) of the line that goes through f(x) and 0, we will end up with the below equation.","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nf(x) = fracf(x_n) - 0x_n - x_n+1\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Now we can solve this for x_n+1, which will give us the new estimate of the root of f(x). ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nx_n+1 = x_n - fracf(x_n)fx_n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Each iteration will give us a better estimate of the root. ","category":"page"},{"location":"RootFinding/#Example-Newton's-method","page":"Numerical root finding","title":"Example Newton's method","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Let's try find the root of an example function f(x) = x^2 - 9. The very first step here is to plot this function to see how ot looks. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\nx = collect(0:0.1:10)\n\nf(x) = x.^2 .- 9\n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([0,10],[0,0], label = \"f(x) = 0\")\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Now let's pick a random x value as our firs guess for example x = 05. Let's first evaluate the f(0.5) as our first step.  ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\nx_n = 0.5\n\ny1 = f(x_n)\n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([0,10],[0,0], label = \"f(x) = 0\")\nscatter!([x_n], [y1], label = \"f(0.5)\")\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"The next step is to calculate the f'(x) in order to evaluate the f'(0.5). From our calculus we know that the first derivative of f(x) (i.e. f'(x)) is f(x) = 2x. Now we can calculate the x_n+1, given that we have all parts of the above equation. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\ndf(x) = 2 .* x\n\n\nx_n1 = x_n - f(x_n)/df(x_n)\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([0,10],[0,0], label = \"f(x) = 0\")\nscatter!([0.5], [y1], label = \"f(0.5)\")\nscatter!([x_n1], [0], label = \"f'(x_n1)\")\nplot!([0.5,x_n1],[y1,0],label =\"slope\")\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"At this point we have the updated x_n, which we called x_n1. To move forward we need to repeat the previous process using the new x_n. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\nx_n = deepcopy(x_n1)\ny2 = f(x_n)\nx_n1 = x_n - f(x_n)/df(x_n)\n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([0,10],[0,0], label = \"f(x) = 0\")\nscatter!([0.5], [y1], label = \"f(0.5)\")\nscatter!([x_n1], [0], label = \"f'(x_n1)\")\nplot!([0.5,x_n1],[y1,0],label =\"slope\")\nplot!([x_n,x_n1],[y2,0],label =\"slope, iter = 2\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"And for the 3rd iteration:","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\nx_n = deepcopy(x_n1)\ny2 = f(x_n)\nx_n1 = x_n - f(x_n)/df(x_n)\n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([0,10],[0,0], label = \"f(x) = 0\")\nscatter!([0.5], [y1], label = \"f(0.5)\")\nscatter!([x_n1], [0], label = \"f'(x_n1)\")\nplot!([0.5,x_n1],[y1,0],label =\"slope\")\nplot!([x_n,x_n1],[y2,0],label =\"slope, iter = 3\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"As you can see after each iteration we get one step closer to the actual root of the function. For the algorithm to stop, you need to set a stopping criterion. The stopping criterion for iterative algorithm is either the number of iterations or a set tolerance for the desired value. For the set number of iterations, for example, you can say stop the algorithm after 10 iteration, independently from the accuracy of the results. On the other hand for the accuracy you can set a minimum accuracy needed for the outcome to be acceptable.","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"tip: Tip\nNormally the stopping criterion is a combination of the two methods in order to minimize the number of evaluations needed as well as the number of iterations.  ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"note: Note\nThe conventional Newton method is very simple, robust, and fast. However, it assumes continuity, it needs the derivative to be provided, and performs root finding for one variable at a time. ","category":"page"},{"location":"RootFinding/#Secant-method","page":"Numerical root finding","title":"Secant method","text":"","category":"section"},{"location":"RootFinding/#Theory-2","page":"Numerical root finding","title":"Theory","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"As mentioned above for Newton Method to work you need to be able to calculate the derivative of your f(x), which is not always possible. A solution to this problem was provided by Secant method, where the derivative is numerically approximated. From our calculus, we know that we can use the below equation as an approximation of f'(x). ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nf(x) approx fracf(x_n) - f(x_n -1)x_n - x_n-1\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"We also know the main equation from the Newton's method. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nx_n+1 = x_n - fracf(x_n)f(x_n)\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"In the next step we can replace the f'(x) with its approximation from the derivative equation. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nx_n+1 = x_n - fracf(x_n)fracf(x_n) - f(x_n -1)x_n - x_n-1\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Which will become the following after a bit of simplification. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nx_n+1 = x_n - fracf(x_n)(x_n - x_n-1)f(x_n) - f(x_n -1)\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"This ultimately results in the below equation. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"\nx_n+1 = fracf(x_n)x_n-1 - f(x_n-1)x_nf(x_n) - f(x_n -1)\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"note: Note\nThe Secant method, generally needs more iterations and at the start of each iteration in needs two points rather than one.","category":"page"},{"location":"RootFinding/#Secant-method-example.","page":"Numerical root finding","title":"Secant method example.","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Let's try to solve the previous problem (i.e. f(x) = x^2 - 9) using Secant method. As it was mentioned in the theory part we need to select two random points to have the algorithm started.","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\nx = collect(-10:0.1:10)\n\nx_n = 0.5\n\nx_n1 = -5\n\n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"f(x) = 0\")\nscatter!([x_n], [f(x_n)], label = \"f(0.5)\")\nscatter!([x_n1], [f(x_n1)], label = \"f(-5)\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Now we need to calculate the f(x_n) and f(x_n-1) using these two values. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\n\nx_n2 = (f(x_n) * x_n - f(x_n1) * x_n1) / (f(x_n) - f(x_n1)) \n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"f(x) = 0\")\nscatter!([x_n], [f(x_n)], label = \"f(0.5)\")\nscatter!([x_n1], [f(x_n1)], label = \"f(-5)\")\nscatter!([x_n2], [f(x_n2)], label = \"f(x_n2)\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"Now we have the new x_n, we can use the combination of this and one of the randomly selected points for the next iteration. For this the point closest to the new x_n may be the best choice. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\n\nx_n1 = -5\n\nx_n3 = (f(x_n2) * x_n1 - f(x_n1) * x_n2) / (f(x_n2) - f(x_n1)) \n\nplot(x,f(x),label = \"Example function\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"f(x) = 0\")\nscatter!([x_n], [f(x_n)], label = \"f(0.5)\")\nscatter!([x_n1], [f(x_n1)], label = \"f(-5)\")\nscatter!([x_n2], [f(x_n2)], label = \"f(x_n2)\")\nscatter!([x_n3], [f(x_n3)], label = \"f(x_n3)\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"In this case we converged to one of the roots after two iterations. However, in real-world cases this process may take longer than two or three iterations. ","category":"page"},{"location":"RootFinding/#Bounded-without-derivative","page":"Numerical root finding","title":"Bounded without derivative","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"The bounded methods are able to function without the use of derivative due to the fact that they use a predefined window for finding the root of the function. ","category":"page"},{"location":"RootFinding/#Bisection-method","page":"Numerical root finding","title":"Bisection method","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"This method is usable for a single variable function as long as the singes of the provided bounds are different. The algorithm finds the middle of the bound by using summing the bound values and then dividing it by two. This new point will be used for replacing one of the initial bounds depending of the signs of the f(b). Over each iteration the bounds move closer to the root of the function. Let's look at a very simple example fo root finding case with bisection method. Say we have f(x) = x^2 - 25 as our test function. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\nx = -30:0.1:30 \n\nf(x) = x.^2 .- 25 \n\nplot(x,f(x), label=\"test function\")\nplot!([-10,10],[0,0],label =\"f(x) = 0\")\nxlabel!(\"x values\")\nylabel!(\"f(x)\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"To set the initial guess of the bounds, we need to choose points that have different signs. In this case b0 = 0 and b1 = 25 fulfil this criterion as f(0) = -25 and f(25) = 600. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\n\nplot(x,f(x), label=\"test function\")\nplot!([-10,10],[0,0],label =\"f(x) = 0\")\nxlabel!(\"x values\")\nylabel!(\"f(x)\")\nscatter!([0,25],[f(0),f(25)],label = \"bounds\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"For the first iteration we will calculate the average of the bounds. In this case it will be 12.5. Now we need to select one of the two windows (i.e. larger than 12.5 or smaller that 12.5) for the next iteration. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\n\nplot(x,f(x), label=\"test function\")\nplot!([-10,10],[0,0],label =\"f(x) = 0\")\nxlabel!(\"x values\")\nylabel!(\"f(x)\")\nscatter!([0,25],[f(0),f(25)],label = \"bounds\")\nscatter!([12.5],[f(12.5)], label = \"middle bound\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"As you can see from the plot the lower bound appears to meet the needed criteria while the higher one does not. So now we are finding the middle of the lower bound, which is 6.25. Let's perform what we did before again. ","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"using DataSci4Chem\n\n\nplot(x,f(x), label=\"test function\")\nplot!([-10,10],[0,0],label =\"f(x) = 0\")\nxlabel!(\"x values\")\nylabel!(\"f(x)\")\nscatter!([0,25],[f(0),f(25)],label = \"bounds\")\nscatter!([12.5],[f(12.5)], label = \"middle bound 1st itr\")\nscatter!([6.25],[f(6.25)], label = \"middle bound 2nd itr\")\n\n","category":"page"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"In this case again we are choosing the lower bound. However, as you can intuitively see, the fourth iteration will select the upper bound. Ultimately, the bounds become smaller and smaller until either we meet the accuracy tolerance or the max number of iteration criteria. ","category":"page"},{"location":"RootFinding/#Additional-resources","page":"Numerical root finding","title":"Additional resources","text":"","category":"section"},{"location":"RootFinding/","page":"Numerical root finding","title":"Numerical root finding","text":"There are several other numerical root finding methods that can be used for your work (e.g. Roots.jl). Please note that all optimization and root finding problems could be converted to another. So these tools may be useful for applications beyond simple root finding. ","category":"page"},{"location":"Matrix/#Matrix-Manipulation","page":"Matrix manipulation","title":"Matrix Manipulation","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Matrices are multi-dimensional data containers, which have very important properties enabling a branch of mathematics called Linear Algebra. Matrices can have multiple dimensions. However, the most commonly used type is a two dimensional matrix (e.g. X_mn) or m times n. The first dimension of a matrix (i.e. m) is the number of rows and the second dimension (i.e. n) is the number of columns of that matrix. A matrix with one of dimensions being one is called a vector. Matrices may contain one or multiple data types, including mixed data types (e.g. combination of strings and integers). A matrix with multiple type data is called an Array while the homogeneous data container is a matrix. This module only focuses on the homogeneous matrices containing only numerical entries, given their mathematical properties. ","category":"page"},{"location":"Matrix/#Matrix-dimensionality","page":"Matrix manipulation","title":"Matrix dimensionality","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"The very first step to be able to work with matrices is being able to handle them, including being able to select specific rows, columns, and/or entries in a matrix. As mentioned before each entry in a matrix has its own coordinates (i.e. the row and column number). For example, the a_21 represents the entry on the second row and the first column. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\nA_mn = \nbeginpmatrix\na_11  a_12  cdots  a_1n \na_21  a_22  cdots  a_2n \nvdots   vdots   ddots  vdots  \na_m1  a_m2  cdots  a_mn \nendpmatrix\n","category":"page"},{"location":"Matrix/#Entry-selection","page":"Matrix manipulation","title":"Entry selection","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"In julia to select an entry of a matrix you can use \"[m,n]\", where m is the row number and n is the column number. It should be noted that these numbers are also referred to as indices. In the below example we first generate a matrix of 15 by 20 filled by random numbers, which will be used for our examples.","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\n# Generating the data\n\nm = 15          # number of rows\nn = 21          # number of columns\n\nX = randn(m,n)\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"As you can see, we have generated our matrix of random floats and have stored it in a variable called X. Now as our first example we will attempt at selecting the matrix entry at the row 5 and column 20. To do that we use the provided coordinates with \"[]\". Here we first select the specified entry and store it in the variable \"x1\" and then printed. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nx1 = X[5,20]\n\nprintln(x1)\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"We can also select more than one entry at a time. For example if we want to select the entries between 3rd and 10th rows on the 2nd column we take advantage of ranges (i.e. 3:10). Similar to the single entry selection we put the relevant range in the spot for rows and select the column #2. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nx2 = X[3:10,2]\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"As you can see, the output of this operation is a matrix of 8 by 1, thus a vector of 8 elements. We can perform the range selection in both row and column level at the same time. The example below shows how to select rows 5:10 and columns 1:3. This should result into a 6 by 3 matrix. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nX1 = X[5:10,1:3]\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"There are also cases where you would like to select a column or an entire row in a matrix. In this case also we can use ranges expressed by \":\". Since this is the full range from 1:end you do not need to specify the details. For example for selecting the second column of the X we can use the expression X[:,2], which implies that we are selecting all the rows in the second column. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nX2 = X[:,2]\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"note: Note\nPlease note that as a generally accepted rule, the matrices and vectors are represented with CAPITAL letters (e.g. X) while the entries are represented with small letters (e.g. x). ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"You can also select multiple columns or rows of a matrix. In this example we are selecting rows 3:5 of the matrix X. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nX3 = X[3:5,:]\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"So far we have selected rows and/or columns that are next to each other, thus accessible with ranges. We can also access entries in a matrix that are not next to one another. In the below example we are selecting the columns 1, 3, and 21 of the matrix X. For this we need to generate a vector of the column indices (i.e. [1,3,21]), which is used for our operation. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nX4 = X[:,[1,3,21]]\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"note: Note\nWhen setting indices for a matrix or a dataframe, you must work with integers that are larger than zero or boolians. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Now that we know how to select entries or chunks of a matrix, we can start working on matrix operations. ","category":"page"},{"location":"Matrix/#Matrix-operations","page":"Matrix manipulation","title":"Matrix operations","text":"","category":"section"},{"location":"Matrix/#Element-wise","page":"Matrix manipulation","title":"Element wise","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Most matrix operations are divided into two categories: element wise and the matrix wise. For the element vise operations the two matrices must have exactly the same size as the desired operation is performed element by element. Consequently, the resulting matrix will have the same size as the starting matrices. ","category":"page"},{"location":"Matrix/#Summation","page":"Matrix manipulation","title":"Summation","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"An example of such operations is summing or subtracting two matrices. Let's generate two matrices 4 by 5 populated with random numbers called A and B. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nA = rand(4,5)\n\nB = rand(4,5)\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Now we can try to sum up these two matrices and store the results in the matrix C. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nC = A + B\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"The matrix D is the result of subtraction of two matrices A and B. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nD = A - B\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"tip: Tip\nThe operation summation has the commutative and associative properties. In other words the following is correct: A + B = B + A (commutative),\n(A + B) + C = A + (B + C) (associative).","category":"page"},{"location":"Matrix/#Transpose","page":"Matrix manipulation","title":"Transpose","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Another very useful element wise matrix operation is the \"transpose\" operation. When a matrix is transposed its rows and columns are switched. This means that if you have started with X2_32, you will end up with matrix X2^T_23. In the below example we have a 3 by 2 matrix X2 and we will try to transpose it to X2_t. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nX2 = [1 2 ; 4 3 ;  5 4]\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nX2_t = DataSci4Chem.transpose([1 2 ; 4 3 ;  5 4])\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"note: Note\nA transposed matrix X is typically denoted as X^T  or X^. Within this documentation we will use the X_t for the code snippet.","category":"page"},{"location":"Matrix/#Scalar-multiplication","page":"Matrix manipulation","title":"Scalar multiplication","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Another element wise matrix operation is the multiplication of a scalar (i.e. a number) to a matrix. Here the scalar is multiplied into each element individually, thus element wise. For example if we multiply the scalar 2 to the matrix X2 we will get the following. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\n2 * X2\n","category":"page"},{"location":"Matrix/#Element-wise-multiplication","page":"Matrix manipulation","title":"Element wise multiplication","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"The last element wise matrix operation that is discussed here is the element-wise matrix multiplication or Hadamard product. This operation is denoted as \"odot\" and is performed using \".*\" in julia language. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nX2 .* (2 * ones(3,2))\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"In the above example with the function ones(3,2) we are generating a 3 by 2 matrix of ones, which is multiplied by the scalar 2, resulting in a 3 by 2 matrix of twos. In the next step the two matrices are multiplied element wise. As you can intuitively imagine and combination of these three components will result in the same output. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\n2 * X2 .* ones(3,2)\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"or ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\n2 * (X2 .* ones(3,2))\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"note: Note\nThis can be done due to the associative properties of the element wise matrix multiplication.","category":"page"},{"location":"Matrix/#Matrix-wise","page":"Matrix manipulation","title":"Matrix wise","text":"","category":"section"},{"location":"Matrix/#Matrix-multiplication","page":"Matrix manipulation","title":"Matrix multiplication","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"One of the most important matrix wise operations is the matrix multiplication. Let's say we have a matrix A_mp and a second matrix B_pn for these matrices to be multipliable they must have the same inner dimensions.","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\nA_mp times B_pn = C_mn\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"As you can see the result of this multiplication is a matrix C_mn. Each entry in the product matrix is the result of first element-wise multiplication of the first matrix rows to the second matrix columns followed by summation of those products. This process can be described with the below formula. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\ni = 1m  j = 1n \n\nc_ij = sum_k=1^p a_ikb_kj  \n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Let's see this in practice: ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\nA = \nbeginpmatrix\n1  6 \n9  3 \nendpmatrix\n\n\n\nand\n\nB = \nbeginpmatrix\n0  -1 \n-1  2 \nendpmatrix\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Based on the above formula the first entry of the c_11 will be calculated as:","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\n\nc_11 = a_11b_11 +  a_12b_21 = 1 times 0 + 6 times -1 = -6  \n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"while the c_12 is calculated a following.","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\n\nc_12 = a_11b_12 +  a_12b_22 = 1 times -1 + 6 times 2 = 11  \n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Following this process we can calculate the product os A and B. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\n \nbeginpmatrix\n1  6 \n9  3 \nendpmatrix\n\ntimes\n \nbeginpmatrix\n0  -1 \n-1  2 \nendpmatrix = \n\nbeginpmatrix\n-6  11 \n-3  -3 \nendpmatrix\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"note: Note\nThis matrix multiplication has the following properties: 0 times A = 0, A times 0 = 0 \nI times A = A, A times I = A\nA(B + C) = AB + AC, (A + B)C = AC + BC\n(A times B)^T = A^T times B^T ","category":"page"},{"location":"Matrix/#Matrix-powers","page":"Matrix manipulation","title":"Matrix powers","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Matrix power is an extension of the matrix multiplication where A^n = prod_i=1^n A, which denotes n multiplications of the matrix A. However, it should be noted that this is only possible for square matrices as non-squared matrices cannot be multiplied by themselves. ","category":"page"},{"location":"Matrix/#Inverse-matrix","page":"Matrix manipulation","title":"Inverse matrix","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Calculation of the inverse matrix (i.e. A^-1) is one of the most fundamental operations that you will do with matrices. It has applications in regression, optimization, matrix decomposition and many other areas of scientific computing. For a matrix to be \"invertible\" (i.e. nonsingular), it has to satisfy two criteria: ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"it must be square \nA^-1 times A = I. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"In fact for calculating the inverse of a matrix you can use the second criteria for invertible matrices. Let's look an example for this. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\nbeginpmatrix\na  b \nc  d \nendpmatrix\n\ntimes \n\nbeginpmatrix\n1  -1 \n1  2 \nendpmatrix\n\n= \n\nbeginpmatrix\n1  0 \n0  1 \nendpmatrix\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"If we solve this problem we will end up with the below matrix. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\nbeginpmatrix\na  b \nc  d \nendpmatrix\n\ntimes \n\nbeginpmatrix\n1  -1 \n1  2 \nendpmatrix\n\n= \nbeginpmatrix\na+b  2b-a \nc+d  2d-c \nendpmatrix\n\n=\n\nbeginpmatrix\n1  0 \n0  1 \nendpmatrix\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Now we have a set of four equations and four variables that can be rewritten as a system of equations. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\na + b = 1\n2b - a = 0 \nc + d = 1 \n2d + c = 0 \n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Solving these equations ultimately will result in the inverse matrix.","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"\nbeginpmatrix\n1  2 \n1  -1 \nendpmatrix^-1\n\n= \nbeginpmatrix\n0333  -0333 \n0333  -0666 \nendpmatrix\n\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"You can calculate the inverse of invertible matrices using the functions inv() or pinv(-) (i.e. pseudo inverse). ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"using DataSci4Chem\n\nA = [1 2; 1 -1]\ninv(A)\n","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"tip: Tip\nFor a matrix X, which is not square, thus noninvertible, the X^TX matrix is square and has very special characteristics. ","category":"page"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"note: Note\nThe inverse matrix also has a lot of interesting properties: (A^-1)^-1 = A \n(A^T)^-1 = (A^-1)^-T\nif y = Ax where x in R^n and A is invertible, then x = A^-1 y. ","category":"page"},{"location":"Matrix/#Matrix-decomposition","page":"Matrix manipulation","title":"Matrix decomposition","text":"","category":"section"},{"location":"Matrix/","page":"Matrix manipulation","title":"Matrix manipulation","text":"Matrix decomposition is another important operation where a matrix X is decomposed/factorized into product matrices. There are several matrix decomposition methods, depending on the applications. For example for solving systems of equations LU decomposition is employed. One of the highly relevant matrix decomposition approaches is singular value decomposition (SVD). The SVD decomposes a matrix X into the product is three matrices U_m times n, D_n times n, and V_n times n^T. The matrix U_m times n is the left singular matrix and it represents a rotation in the matrix space. The D_n times n is diagonal matrix and contains the singular values. Finally, V_n times n^T is called the right singular matrix and is associated with rotation. For more details of SVD please look at SVD course material.","category":"page"},{"location":"DataExplore/#Data-exploration","page":"Data exploration","title":"Data exploration","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Data exploration is a set of tools that you can use to look at, visualize, and infer about an unknown dataset. The tools explored here will include data summary, distribution of variables, missing values, and finally variable reduction. It should be noted that this is not a complete list of potential tools that can be used for data exploration. ","category":"page"},{"location":"DataExplore/#Data-summary","page":"Data exploration","title":"Data summary","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"One of the first steps in getting the data summary is to assess the number of variables and measurements. As a convention we tend to put the variables in columns while putting the measurements as rows. For dataframes this is very simple to assess while for matrices this can become tricky. Let's for example take a look at the \"iris dataset\". ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\ndata = dataset(\"datasets\", \"iris\");\n\ndata[1:5,:]\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"We can see that there are five variables in the dataset. Four of which are numerical while one of the variables is categorical. To be able to explore the data, we should look at the mean, median, maximum, minimum, and standard deviation.","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"For the calculation of mean (i.e. average) we can use the function mean(-). The mean can be calculated column wise, row wise, and on the full dataset. In this case we are interested to evaluate the mean of each column as here they represent each variable. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"note: Note\nPlease note that functions mean, median, etc work on matrices rather than dataframes. Therefore you must to first convert your data into a matrix via Matrix(-). Also, categorical data cannot be converted to a matrix as matrices cannot hold mixed data.","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\ndata_c = Matrix(data[:,1:4])\nmd = mean(data_c,dims = 1 )\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Similar to the mean, there are built in functions for median(-), minimum(-), and maximum(-). ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"In addition to the data boundaries, we usually want to know about the presence of \"NAN\" and/or missing values. In the below section a few simple ways of dealing with such entities will be discussed. For the missing values you can use the julia base function ismissing(-), which will generate a logical value of one for \"missing\" and zeros for the contrary. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nx = [1, missing, 3]\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"To detect this missing value, we can use combination of ismissing(-) and the vectorization. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nismissing.(x)\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"This operation can be expanded to multidimensional matrices as well. Additionally, this output can be used for finding and replacing the missing values with more workable values. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nx1 = deepcopy(x)\n\nx1[ismissing.(x)] .= -99\n\nx1\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"In case of dataframes you can use the function replace!(-) provided via DataFrames.jl package.","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\ndf = DataFrame(x = [1, missing, 3])\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nreplace!(df.x, missing => -99)\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Another entity that can be found in large and complex datasets is \"NaN\". Most functions in have difficulties dealing with \"NaN. For example the sum of NaN and any number will result in a NaN. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\n2 + NaN\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"To mitigate the issues associated with NaN, you can either remove/replace them with a number or us can exclude them from your calculations. To find and replace the NaN values, you need to work with matrices and you can use the function isnan(-), which operates the same way as the function ismissing(-). ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nx = [1, NaN, 3]\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nx1 = deepcopy(x)\n\nx1[isnan.(x)] .= -199\n\nx1\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"tip: Tip\nWithin the DataFrames.jl package implemented in the DataSci4Chem.jl you have access to the function describe(-) which is able to parse a dataframe and provide you with this basic information about your table. This command can handle both numerical and categorical data as in a dataframes, the columns independent from each other. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\ndescribe(data)\n","category":"page"},{"location":"DataExplore/#Missing-values","page":"Data exploration","title":"Missing values","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"In this section we are tackling issues related to missing values as well as outliers etc. The main idea behind this is that one or more data points are removed or replaced due to uncertainty or the fact that they are undefined. In the previous section we learned how to identify these data points. Here we will go through different strategies to handle this problem. There are two main strategies for dealing with missing values, namely: removal and imputation. ","category":"page"},{"location":"DataExplore/#Removal","page":"Data exploration","title":"Removal","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"If there are a few data points missing in your dataset, you can remove those measurements (i.e. rows) from your dataset prior to model building. However, this may cause removal of several measurements from your dataset, reducing your degrees of freedom. Another option is the removal of the variable with a high frequency of \"NaN\" and/or \"missing\" values. This option can be used when there are enough variables to be used for your model. The removal based methods can be used only when we are dealing with a small number of data points that must be replaced. ","category":"page"},{"location":"DataExplore/#Imputation","page":"Data exploration","title":"Imputation","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Imputation is the process of the replacing a missing value with the most likely estimate for that data point. There are several tools ranging from simple random replacement to more sophisticated methods such as external regression to replace the missing values. Here we will discuss hot-deck, mean/median imputation, and regression. ","category":"page"},{"location":"DataExplore/#Hot-deck","page":"Data exploration","title":"Hot-deck","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"This method tends to first sort the data in ascending order. In the next step the last observation is carried over to replace the missing value. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\ndf = DataFrame(:a => [1.0, 2.0, missing, missing, 5.0], :b => [1.1, 2.2, 3.3, missing, 5.5])\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\n# Imputed DF\n\ndf = DataFrame(:a => [1.0, 2.0, 2, 2, 5.0], :b => [1.1, 2.2, 3.3, 3.3, 5.5]) \n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"warning: Warning\nPlease note that your data must be sorted. Applying the sort function in most cases puts the missing values at the top or the bottom of the matrix/dataframe. This implies that you are replacing the missing values with the largest or the smallest measurements.","category":"page"},{"location":"DataExplore/#Mean/median","page":"Data exploration","title":"Mean/median","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Another strategy for imputing the missing values is to use the mean or the median of each variable to replace the missing values in that specific variable. The main advantage of this method is that the mean or the median of the data will remain constant, which may be advantageous depending on the scope of the study. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\n# Imputed DF\n\ndf = DataFrame(:a => [1.0, 2.0, 4, 4, 5.0], :b => [1.1, 2.2, 3.3, 4.3, 5.5]) \n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"warning: Warning\nDepending on the number of missing points this approach may change the structure of your dataset, thus impacting your final model.","category":"page"},{"location":"DataExplore/#Regression","page":"Data exploration","title":"Regression","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Regression is another important approach for imputation of missing values. If the regression strategy only uses the variable in question itself, it is called interpolation. On the other hand, if the other variables in your dataset are used the variable with missing values, this is called conventional regression based imputation. In this case, all the other variables in your dataset are used to predict the variable with missing values. In the next step, this model is used for imputation of the missing values. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"warning: Warning\nThis method depending on the number of imputed values may bias your system towards the regression model used for imputation. Using a stochastic approach where some of the variables are excluded at random has shown a potential for higher accuracy imputation.","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"There are also more sophisticated approaches for data imputation, for example SVD. There is julia package called Impute.jl fully dedicated to different imputation approaches. ","category":"page"},{"location":"DataExplore/#Data-dimensionality","page":"Data exploration","title":"Data dimensionality","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"In many cases, our datasets have multiple dimensions (i.e. variables). However, not all the variables contribute to a potential model in the same manner. Sometimes these variables are redundant, for example highly correlating variables. In those cases, you do not need to have all those variables included in your model, as one of them will bring enough information for the potential model. The very first step to detect such cases is to detect such potential redundancies. ","category":"page"},{"location":"DataExplore/#Correlation-analysis","page":"Data exploration","title":"Correlation analysis","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"The best approach to perform such assessment is calculate pair wise correlation coefficient analysis. The correlation coefficients can be calculated for a linear relationship (i.e. Pearson correlation) or for a nonlinear case (i.e Spearman correlation). ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Pearson correlation assesses the linear relationship between two variables as follows: ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"\nr_x_ix_i+1 = fraccov(x_ix_i+1)sigma _x_i sigma _x_i+1\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"These calculations can be performed using the function cor(-) implemented via this package. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nr_p = cor(data_c) \n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Here since we have provided a matrix to the function, we have a square matrix with diagonal of one. This is exactly what we expect as the diagonal represents the autocorrelation between each variable and itself. The other pixels, on the other hand, indicate the relationship between two pairs of variables. For example the location r_p[4,1] = 0.8179 is the linear correlation coefficient between first and fourth variables. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nheatmap(r_p,xlabel = \"variable number\" , ylabel = \"variable number\", colorbar_title = \"Pearson correlation\")\n\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"The r_p closer to one indicates a more significant linear relationship between two sets of variables. We can see these relationships clearly in the below scatter plots. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nl_c = r_p[4,1]\n\nscatter(data_c[:,1],data_c[:,4], xlabel = \"Sepal Length\", ylabel = \"Petal Width\", label = \"$l_c\")\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"using DataSci4Chem\n\nl_nc = r_p[2,1]\n\nscatter(data_c[:,1],data_c[:,2], xlabel = \"Sepal Length\", ylabel = \"Sepal Width\", label = \"$l_nc\")\n","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Spearman correlation is for detection of monotonic relationship between two variables, independently from its linearity. Spearman correlation is a non parametric method and thus works with the ranks rather than the actual values. To calculate Spearman correlation coefficient between a set of variables you can use the function corspearman(-) in a similar manner to the cor(-) function. ","category":"page"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"tip: Tip\nLooking at the correlation matrix above, I would use only variable one and two for any future model building as variables three and four are covered by the first variable. ","category":"page"},{"location":"DataExplore/#Matrix-decomposition","page":"Data exploration","title":"Matrix decomposition","text":"","category":"section"},{"location":"DataExplore/","page":"Data exploration","title":"Data exploration","text":"Another approach for the dimensionality reduction is the application of matrix decomposition tools such as SVD or PCA where the scores' matrix for a selected number of principal components represent a large enough variance in the dataset to be used for further model building. An example of such systems is Principal Component Regression. ","category":"page"},{"location":"svd/#Singular-Value-Decomposition","page":"SVD","title":"Singular Value Decomposition","text":"","category":"section"},{"location":"svd/#Introduction","page":"SVD","title":"Introduction","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"In many cases, a data matrix can be very well approximated by a sum (\"linear combination\") of products of vectors. As a trivial example, consider the matrix","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"A = \nbeginpmatrix\n1  2  3 \n3  6  9 \n0  0  0 \n2  4  6\nendpmatrix","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"Each row of this matrix is a multiple of the row vector beginpmatrix 1  2  3 endpmatrix, and in matrix notation we can write","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"A = \nbeginpmatrix\n1  2  3 \n3  6  9 \n0  0  0 \n2  4  6\nendpmatrix\n=\nbeginpmatrix\n1302\nendpmatrix\nbeginpmatrix\n1  2  3\nendpmatrix","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"so in this case the \"sum of products of vectors\" is just one term. Here is a larger example: we measure the infrared spectra of 3000 samples and put them in matrix as rows. Each spectrum contains 1400 points, so the data is a 3000times1400 matrix. To get a view of this rather large matrix we  translate numbers into color intensity, and we also make plots of the first five rows: (Image: 1component_example.png) It seems that here too, each row is a multiple of the same row vector (note that this will not be exactly so, because the noise on the data will not be the same in each row). The chemical interpretation of this fact is that apparently all the samples contain only one compound, but with different concentrations. To a good approximation we can write ","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"B = \nbeginpmatrix\nu_1u_2vdotsu_3000\nendpmatrix\nbeginpmatrix\nv_1  v_2  ldots  v_1400\nendpmatrix","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"where the u_ivalues are (proportional to) the concentrations, and the vector beginpmatrix v_1  v_2  ldots  v_1400 endpmatrix is the spectrum of the compound (=its absorption at 1400 different IR frequencies). Note that we need only 3000+1400 numbers to characterize the entire matrix, which contains 3000times1400 numbers, so we have a data reduction by a factor of about 1000! Of course, this situation will not occur very often. As a  more realistic example, here is a different set of IR spectra, again containing 3000 samples (=rows): (Image: 1component_example.png) Looking at the graphs of the first 5 rows, we see that this matrix can not be written as the product of two vectors: comparing the  intensities at positions 550 and 1200 of the blue and red data, it is clear that these two matrix rows are not multiples of each other (and therefore cannot be multiples of one and the same row vector). However, in this case, it turns out that the matrix can be very well approximated by a sum of two vector products:","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"C = \nbeginpmatrix\nu_11u_21vdotsu_30001\nendpmatrix\nbeginpmatrix\nv_11  v_12  ldots  v_11400\nendpmatrix+\nbeginpmatrix\nu_12u_22vdotsu_30002\nendpmatrix\nbeginpmatrix\nv_21  v_22  ldots  v_21400\nendpmatrix\n","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"where we needed an extra index for the u and v vectors since there are now two of each. The value u_ij can be interpreted as the concentration of compound j in sample i, and the value v_ijcan be interpreted as the spectral absorption intensity of compound i at IR frequency j. This can be written more elegantly as a matrix product (and we can interpret the indices as matrix indices):","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"C = \nbeginpmatrix\nu_11  u_12u_21u_22vdotsvdotsu_30001 u_30002\nendpmatrix\nbeginpmatrix\nv_11  v_12  ldots  v_14001\nv_21  v_22  ldots  v_14002\nendpmatrix","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"So in this case we need 2(3000+1400) numbers to characterize the matrix, still a huge reduction in data. This idea can be extended to sums of more than two products of vectors.","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"In many practical situations, matrices turn out to be such sums of a small number of vector products: in the case where the matrix contains sample spectra (IR, mass, NMR, ...), this is simply the mathematical expression of the fact that the samples contain a finite number of compounds, each with their own spectrum (but with different concentrations in the samples). However, when the number of components is larger than 1 it generally becomes difficult to find out how many there are by just looking at the data. For instance in the case of matrix C above, how did we know there were not more than 2 components required to describe it? (we will soon be able to answer this). Two questions naturally arise: (1) is there a mathematical way of estimating how many components there are present in a data matrix? and (2) can we quantify how well the sum of component products approximates the original data matrix?","category":"page"},{"location":"svd/#Singular-Value-Decomposition-Theorem","page":"SVD","title":"Singular Value Decomposition Theorem","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"Theorem: any m times n matrix A (with mge n) can be decomposed as","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"beginpmatrix\nA\nendpmatrix\n=\nbeginpmatrix\nU\nendpmatrix\nbeginpmatrix\ns_1      s_2      ddots      s_n\nendpmatrix\nbeginpmatrix\n                   V^T                 \nendpmatrix","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"where the middle matrix Sis a diagonal ntimes n matrix with positive or zero elements (the singular values, basically \"weights\"), U has the same dimensions as Aand has columns that are orthonormal vectors, and V^T is a square ntimes nmatrix with rows that are orthonormal vectors (so that Vis a square matrix with colums that are orthonormal vectors). This latter orthogonal-vector property of the columns of U and the rows of V^T (or V) can be written explicitly as","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"sum_i u_iju_ik = delta_jk","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"sum_j v_ijv_ik = delta_jk ","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"If the s_iare sorted by order of decreasing value, this decomposition is unique (apart from forming linear combinations of columns of U and rows of V^T that have the same s_i values). The names USV^Tof the matrices in the product are standard. Note that the diagonal matrix Sin the middle \"picks out\" columns from the left matrix and rows from the right matrix, and that we can also write the above decomposition as a so-called \"dyadic summation\":","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"beginalign \nbeginpmatrix\nA\nendpmatrix\n= s_1\nbeginpmatrix\nu_11u_21 vdots  u_m1\nendpmatrix\nbeginpmatrix\nv_11 v_12  ldots  v_1n  \nendpmatrix\n+\ns_2\nbeginpmatrix\nu_12u_22 vdots  u_m2\nendpmatrix\nbeginpmatrix\nv_21 v_22  ldots  v_2n  \nendpmatrix\n+ldots+\ns_n\nbeginpmatrix\nu_1nu_2n vdots  u_mn\nendpmatrix\nbeginpmatrix\nv_n1 v_n2  ldots  v_nn  \nendpmatrix\n=s_1bf u_1 bf v^T_1+s_2bf u _2 bf v^T_2+ldots+s_nbf u_n bf v^T_n\nendalign ","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"where in the second line we used boldface letters to denote column vectors (with the transposes bf v^T_k being row vectors). This shows that the example matrices ABCabove were special cases in which the only nonzero s_iwere the first (for Aand B) and the first and second (forC`$).","category":"page"},{"location":"svd/#Example","page":"SVD","title":"Example","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"For matrix the A above we have","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"beginpmatrix\n1  2  3 \n3  6  9 \n0  0  0 \n2  4  6\nendpmatrix =\nbeginpmatrix\n  0267   0951   -0153\n 0802  -0132    0583\n  00        00        00\n 0535  -0278  -0798\nendpmatrix\nbeginpmatrix\n14     \n  0   \n   0\nendpmatrix\nbeginpmatrix\n1  2  3 \n3  6  9 \n0  0  0 \n2  4  6\nendpmatrix\n= 14 beginpmatrix\n  0267 \n 0802 \n  00  \n 0535\nendpmatrix\nbeginpmatrix\n1  2  3\nendpmatrix","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"The SVD decomposition (and the dyadic summation) is exact. In addition, for many data matrices that one encounters in practice, it turns out that the first few weights s_iare much larger than all the others. This means that if we truncate the dyadic summation after a small number of terms, we still get a good approximation of the original matrix. How good?","category":"page"},{"location":"svd/#Matrix-approximation","page":"SVD","title":"Matrix approximation","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"To define quantitatively how well we approximate a given matrix X with another matrix tildeX, we sum the squares of the differences per element:","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"X-tildeX=sqrtsum_i sum_j x_ij-tildex_ij^2","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"Then it can be shown that of all possible r-term summations ","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"tildeX = sum_k=1^r s_k bf u_k bf v^T_k","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"the minimum value of X-tildeX is obtained precisely for the truncated r-term summation obtained from the first k weights in the singular-value decomposition. In this sense, the truncated dyadic summation of vector products that we obtain from the SVD of a given matrix is the best possible approximation of this matrix. It can be shown that if we construct the approximation tildeX using the first r singular vectors, then","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"X-tildeX= sum_j=r+1^n s_j^2","category":"page"},{"location":"svd/#Doing-it-yourself","page":"SVD","title":"Doing it yourself","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"Julia has a function svd that returns the SVD of any matrix. This function can be loaded (together with many other matrix functions) with using DataSci4Chem.","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"using DataSci4Chem \n\nA = [[1,3,0,2] [2,6,0,4] [3,9,0,6]]\nF = DataSci4Chem.svd(A)","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"after which the matrices USV^Tare contained in FU, FS and FVt (the nontransposed matrix Vis contained in FV). The SVD is calculated numerically, and in the case of matrix Awe run into the machine precision:","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"\nprintln(F.S)\n","category":"page"},{"location":"svd/#Applications","page":"SVD","title":"Applications","text":"","category":"section"},{"location":"svd/#Sets-of-sample-spectra","page":"SVD","title":"Sets of sample spectra","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"Let us calculate the SVD of matrix C above, and have a look at the first 5 weights s_1ldotss_5:","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"julia> F = svd(C)\njulia> F.S[1:5]\n5-element Vector{Float64}:\n 312.83248348826254\n 124.30327344440433\n   0.9221245484802668\n   0.9160134372171663\n   0.914885397452181","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"tip: Tip\nYou can use the function readinterndata(-) to directly read the C from the GitHub repository. ","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"Clearly the list of weights is completely dominated by the first two. This is the quantitative version of our earlier hunch that each sample in the matrix C contained only two compounds. Note that unlike the SVD of matrix A, the remaining weights are not zero, but very small. This is because the data in C also contain a noise contribution, which is contained in the remaining singular vectors. How well can we approximate C with the first two terms in the summation? We plot the first row of C and of its approximation obtained from just the first two components of the SVD:","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"julia> Capprox = F.S[1]*F.U[:,1]*Transpose(F.Vt[1,:]) + F.S[2]*F.U[:,2]*Transpose(F.Vt[2,:])\njulia> plot([C[1,:] Capprox[1,:]], label=[\"C\" \"Capprox\"])","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"(Image: svdapprox.png) Isn't that nice? Not only do we get the number of components present in the samples, but the approximation constructed from the first two singular vectors is actually smoother than the original data! Try to think why this is. More importantly, the SVD method to analyze a data matrix also works when the number of components is larger (and it would be difficult to \"guess\" the number of components contained in the samples).","category":"page"},{"location":"svd/#Chemical-Kinetics","page":"SVD","title":"Chemical Kinetics","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"To investigate time-dependent processes such as chemical reactions, one often measures time series of spectra (NMR, IR, Raman, ...) to observe time-dependent changes in the molecular composition of a sample. Putting such a time series of spectra in a matrix, we can analyze the data with SVD to obtain the number of species involved in the process (since each will have its own time dependence). This can be valuable if one or more of the species are intermediates, that may are present in comparatively low concentrations compared to the initial (reactant) and final (product) compounds, and therefore difficult to observe separately. Suitable analysis of the singular vectors can even reveal the spectra of the intermediate species. Examples include shuttling molecular motors and amyloid formation.","category":"page"},{"location":"svd/#Image-compression","page":"SVD","title":"Image compression","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"Digital images are matrices of intensity values, and we can apply SVD to approximate these matrices. In this way, you can reduce the file size of an image. Here is an example using a healthy-looking image from the Julia standard-image database:","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"\nimg = testimage(\"peppers_gray.tif\")\nT = channelview(img)[1,:,:]\nF = svd(T)\nr = 5\nTapprox = F.U[:,1:r]*Diagonal(F.S[1:r])*F.Vt[1:r,:]\n\nGray.(Tapprox)","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"The quality of the compressed image depends on the number r of singular vectors that we include in the approximation, see below. With r=50 we have a compression of about a factor of 10. (Image: svdpeppers.png)","category":"page"},{"location":"svd/#Further-reading","page":"SVD","title":"Further reading","text":"","category":"section"},{"location":"svd/","page":"SVD","title":"SVD","text":"D. Kalman, \"A Singularly Valuable Decomposition: The SVD of a Matrix\"","category":"page"},{"location":"svd/","page":"SVD","title":"SVD","text":"S. L. Brunton, \"Data Driven Science & Engineering\", chapter 1: Singular Value Decomposition","category":"page"},{"location":"fit/#Curve-fitting","page":"Curve fitting","title":"Curve fitting","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Curve fitting is the process of postulating a function that explains the trend in the data only based on how well the variance in the data is explained. Curve fitting may refer to both data interpolation and regression. Here we will mainly focus on the regression. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"There are several algorithms that are used for solving both linear and non-linear regression problems. One of the most commonly used approaches for regression analysis is the least squares.","category":"page"},{"location":"fit/#Least-squares","page":"Curve fitting","title":"Least squares","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"For linear regression problems the least squares solution tries to minimize the squared distances between each measured data point and the potential line/function at the same time. Let's imagine a case where we have measured the signal associated with different concentrations of a chemical in solution (i.e. external standard calibration curve). ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\ncal = [5.871\t1\n\t   16.224\t2\n\t   16.628\t2\n\t   21.9\t    3\n\t   32.172\t4\n\t   33.006\t4\n\t   44.512\t5\n\t   53.285\t6\n \t   55.985\t6\n\t   104.403\t9]\n\nscatter(cal[:,1],cal[:,2],label = \"measured data\",xlabel = \"concentration\",ylabel=\"signal\")\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"The solution to this problem is a function f(x) = ax + b, where a and b are the slope and intercept of the potential line describing these data. As it was stated before, we are aiming at minimizing the squared distances between the f(x) and the data points. The first step will be to define the distance between y_i and f(x_i), defined as the difference between the two points resulting in the following:","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\nsum_i=1^n (d_i)^2 \nsum_i=1^n (y_i - f(x_i))^2\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"The least squares algorithm aims at minimizing the sum of these distances (i.e. sum squared residuals) to find the best fitting curve into the data. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\nsum_i=1^n (y_i - f(x_i))^2 rightarrow 0\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Let's assume that our data can be described by f(x) = ax + b, which is a simple linear solution to our problem. This implies that we can rewrite the above equation by plugging in the value of f(x) into our equation. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\nsum_i=1^n (y_i - (ax_i + b))^2 rightarrow 0\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"There are different ways of solving this problem namely: analytically and numerically. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"note: Note\nThe analytical solutions are only possible for linear problems while for nonlinear system the solution must be found numerically. ","category":"page"},{"location":"fit/#Ordinary-least-squares","page":"Curve fitting","title":"Ordinary least squares","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"To find the solution to this we could utilize the systems of equations built using the objective function f(x) and the data. For example, if selecting four points in our data, we will end up with the below system. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\ny_1 = ax_1 + b\ny_2 = ax_2 + b\ny_3 = ax_3 + b\ny_4 = ax_4 + b\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"This system of equations can be translated into a set of matrices.","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\nbeginbmatrix y_1 y_2 y_3 y_4 endbmatrix = beginbmatrix 1  x_1 1  x_2 1  x_3 1  x_4 endbmatrix times \n\nbeginbmatrix b  a endbmatrix\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"As we saw before we can solve this system using the elimination approach. We also can use the solution of ordinary least squares problem to find the two unknown parameters. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\nbeginbmatrix b  a endbmatrix = (X^TX)^-1X^TY \n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"warning: Warning\nPlease note the moment the objective function does not meet the linearity criteria this solution will not work. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\nX = cal[:,1]\nY = cal[:,2]\n\nX1 = hcat(ones(length(X),1),X)\n\nbeta = pinv(X1'*X1)*X1' * Y \n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\nf(x) = beta[1] .+ beta[2].*x \n\nplot!(X,f(X),label=\"model\")\n","category":"page"},{"location":"fit/#Numerical-approach","page":"Curve fitting","title":"Numerical approach","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"This also can be solved numerically. We still start with an objective function f(x) and try to find the parameters of such function through an iterative manner. Let's start with a randomly selected set of parameters for example a=0 and b=10. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\na_p = 0\nb_p = 10\n\nfh(x) = b_p .+ (a_p .* x) \n\nplot!(X,fh(X),label=\"random parameters\")\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Now we can calculate the SSR as a metric for how well our random parameters are performing in modeling the trend in our data. For this we first calculate the residuals of the potential model, and then these residuals are squared and summed. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\nSSR = sum((fh(X) .- Y).^2)\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Now we can update the parameters with new values and repeat this process. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\na_p = collect(range(-1,2,length=10))\nb_p = collect(range(-5,5,length=10))\n\nSSR_m = zeros(length(a_p))\n\nfor i=1:length(a_p)\n\n\tfh(x) = b_p[i] .+ (a_p[i] .* x) \n\tSSR_m[i] = sum((fh(X) .- Y).^2)\n\nend \n\nscatter(SSR_m,label=false, xlabel=\"try\",ylabel=\"SSR\")\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Where the SSR plot has a minimum is the set of model parameters with lowest error and thus the best fit. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\nfh(x) = b_p[argmin(SSR_m)] .+ (a_p[argmin(SSR_m)] .* x) \n\nscatter(cal[:,1],cal[:,2],label = \"measured data\",xlabel = \"concentration\",ylabel=\"signal\")\nplot!(X,f(X),label=\"analytical model\")\n\nplot!(X,fh(X),label=\"numerical model 10 steps\",ls =:dot,lw=3)\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"note: Note\nHigher is the number of the steps, thus higher resolution, of the parameter space exploration, the more accurate results can be obtained. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\na_p = collect(range(-1,2,length=1000))\nb_p = collect(range(-5,5,length=1000))\n\nSSR_m = zeros(length(a_p))\n\nfor i=1:length(a_p)\n\n\tfh(x) = b_p[i] .+ (a_p[i] .* x) \n\tSSR_m[i] = sum((fh(X) .- Y).^2)\n\nend \n\nfh(x) = b_p[argmin(SSR_m)] .+ (a_p[argmin(SSR_m)] .* x) \n\nscatter(cal[:,1],cal[:,2],label = \"measured data\",xlabel = \"concentration\",ylabel=\"signal\")\nplot!(X,f(X),label=\"analytical model\")\n\nplot!(X,fh(X),label=\"numerical model 1000 steps\",ls =:dot,lw=3)\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"tip: Tip\nYou can also use a more data deriven approach to exploring the model parameter space, for example Bayesian regression. More details on how to do this is provided here. ","category":"page"},{"location":"fit/#Nonlinear-fit","page":"Curve fitting","title":"Nonlinear fit","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"There are several numerical approaches that are able to solve both linear and nonlinear problems, referred to nonlinear solvers. For these solvers to work, they need a starting point and the interest window for each parameter. Depending on the implementation, they may have different kernels to solve such systems. For example the package LsqFit.jl incorporated into DataSci4Chem.jl employs the Gauss-Newton algorithm. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"To solve linear problems you need to define your objective model as a combination of independent variables and the model parameters. For example, our current system is defined as following. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\nmodel(x,p) = p[1] .* x .+ p[2]\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Now that the objective function is already built, we can use our data to fit our data. For that we need to provide the algorithm with a set of starting points as well as the data. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\np0 = [0.5, 0.5]\n\nfit = curve_fit(model, X, Y, p0)\nfit.param\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"warning: Warning\nThe starting points must be close to the true value of the parameters otherwise, the algorithm may not be able to find the best fit, particularly for more complex systems. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"For more complex systems, we must provide our algorithm with parameter bounds besides the starting points. These will be particularly helpful for cases that multiple solutions to the system is possible (e.g. Gaussian fit). ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\nlb = [-2.0, -2.0]\nub = [2.0, 2.0]\n\nfit = curve_fit(model, X, Y, p0, lower=lb, upper=ub)\nfit.param\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"warning: Warning\nThe parameter bounds must be float64! If integers are provided, the algorithm will give you an error.","category":"page"},{"location":"fit/#Goodness-of-the-fit","page":"Curve fitting","title":"Goodness of the fit","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Now that we have managed to fit an objective function to our model, we need to evaluate whether the fitted model is good enough, or representative of our data. There are different metrics for this assessment. Here we are going to discuss the residuals, root mean squared error (RMSE), and  coefficient of determination (i.e. R^2).","category":"page"},{"location":"fit/#Residuals","page":"Curve fitting","title":"Residuals","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Residuals are the difference between each y_i and f(x_i). For a model that is able to represent our data well without any systematic error, we want to see a random distribution of the residuals across X. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\nfh2(x) = fit.param[1] .* x .+ fit.param[2]\n\nres = fh2(X) - Y \n\nscatter(X,res,xlabel =\"X values\", ylabel = \"residuals\", label =false)\nplot!([0,105],[0,0],label=false)\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"As you can see from the above figure, there is not a clear trend in the distribution of the residuals, indicating the our model is able to capture the underlying trend in our data. In case of observed trends, we can deduce that our objective function is not well suited to describe such trends. ","category":"page"},{"location":"fit/#RMSE","page":"Curve fitting","title":"RMSE","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"RMSE provides a metrics of the magnitude of the error in the model predictions. As you can deduce from the name, it is a combined measure of residuals. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\nRMSE = sqrtmean(Y - f(X))\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Smaller RMSE values indicate that the model is able to explain higher levels of variance in the data. There is not a clear cut off for RMSE for accepting or rejecting a model. It is mainly used for comparing two or more models against each other.","category":"page"},{"location":"fit/#R2","page":"Curve fitting","title":"R^2","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"R^2 similarly to the other measures is an indicator for the goodness of fit. R^2 in practice is showing how much better your model is in describing your data than the average value. Mathematically the R^2 is calculated as below","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"\nR^2 = 1 - fracsum_i=1^n (y_i - f(x_i))^2sum_i=1^n (y_i - bar y)^2\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"R^2 can range between zero, no trend, to one, perfect correlation. The larger R^2 values show that the fitted model a lot better than the bar Y in describing our data. For example for our model the R^2 can be calculated as follows.","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"using DataSci4Chem\n\n\nres_t = Y .- mean(Y) \n\nR2 = 1 - sum(res.^2)/sum(res_t.^2)\n","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"Usually, R^2 values above 0.6 indicate that the model is able to explain a large portion of variance in the data. ","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"tip: Tip\nFor complex and multivariate systems, R^2 values close to one may indicate an issue of overfitting.","category":"page"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"note: Note\nAnother metrics that can be used for the assessment of your fit quality is the confidence interval (CI) of your model. The CI of your model can be estimated based on the residuals and the t-distribution. There are also numerical approaches such as bootstrapping and leave one out to do these calculations. ","category":"page"},{"location":"fit/#Additional-resources","page":"Curve fitting","title":"Additional resources","text":"","category":"section"},{"location":"fit/","page":"Curve fitting","title":"Curve fitting","text":"For additional resources, please take a look at this MIT open course ware here:. ","category":"page"},{"location":"Basics/#Julia-Programming-Language","page":"Basics","title":"Julia Programming Language","text":"","category":"section"},{"location":"Basics/#Installation","page":"Basics","title":"Installation","text":"","category":"section"},{"location":"Basics/#Julia","page":"Basics","title":"Julia","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"1.\tDownload the long term support (LTS) release for Julia from: https://julialang.org/downloads/","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"2.\tExecute the file and follow the installation steps. Make sure to write down the installation path or use the default path (This information will be required in a later step).","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"(Image: julia_down)","category":"page"},{"location":"Basics/#Visual-Studio-Code","page":"Basics","title":"Visual Studio Code","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"1.\tDownload and install Visual Studio Code (VScode) from: https://code.visualstudio.com/download","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"2.\tTo open the extension marketplace, press (Ctrl+Shift+X) or press the marketplace button on the left side of the screen","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"3.\tSearch for julia. ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"4.\tSelect the first package named Julia and install. ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"5.\tAfter installation restart VS Code for the next steps.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"(Image: julia_ex)","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"To ensure that VS Code can find the installed Julia language:","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"1.\tGo to: file -> preferences -> settings. ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"2.\tSearch for the Julia.executablePath (Figure below).","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"3.\tFill in the path (i.e., installation path noted before) to the Julia executable (Julia.exe). ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"In case you do not have the path you can do the following:\nDefault path for Windows: C:\\Users\\[INSERTUSERNAME]\\AppData\\Local\\Programs\\Julia1.5.3\\bin\\julia.exe\nFor windows, double slashes (\\) need to be used instead of single () because the single slash is interpreted as escape.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"To locate appdata folder, you can press the windows key and type: %appdata%\nCopy path and add \\Local......:\n[Copied path ending with \\AppData]\\Local\\Programs\\Julia-x.x.x\\bin \\julia.exe","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Default path for Mac: \nMacintoshHD/users/[INSERTUSERNAME]/Applications/Julia-x.x.x.app/Contents/Resources/julia/bin/Julia","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"(Image: julia_path)","category":"page"},{"location":"Basics/#Julia-package-installation","page":"Basics","title":"Julia package installation","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"To install packages we first need to start up Julia. To open the Julia REPL for executing commands press Crtl+Shift+P and search for Julia: Start REPL and press enter, opening up the following window:","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"(Image: REPL)","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"In the REPL execute the following lines of code in order to install packages. After a single command is executed, “julia >” re-appears and the next line can be executed (it might take a bit for the packages to finish downloading). Also, the lines are capital sensitive.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"using Pkg\n# Julia official packages\nPkg.add(\"CSV\")\n\n# Julia unofficial packages from repository\nPkg.add(PackageSpec(url=\"https://github.com/EMCMS/DataSci4Chem.jl\"))","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"The second package that is being installed contains all relevant functions and information for the course.","category":"page"},{"location":"Basics/#Basic-programming-knowledge","page":"Basics","title":"Basic programming knowledge","text":"","category":"section"},{"location":"Basics/#Loading-packages","page":"Basics","title":"Loading packages","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Packages are loaded with the using keyword","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"using DataSci4Chem\n\nmean([2,4,2])  #shows that the mean function was loaded from the ACS package\n","category":"page"},{"location":"Basics/#[Repeated-evaluation](https://docs.julialang.org/en/v1/manual/control-flow/#man-loops)","page":"Basics","title":"Repeated evaluation","text":"","category":"section"},{"location":"Basics/#For-loops","page":"Basics","title":"For loops","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"For loops can be used when repeated evaluations of the same code are required. The example below shows the basic functionality of for loops. After the keyword for, comes a range of values for which the code needs to be executed. Then for each of the values in this range (i) the code is executed, which is a simple print function for the example below:","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"for i = 1:11    #iterator\n    println(i)  #code to execute for each value of i\nend","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Alternatively, the step size can be adjusted to skip values that are not of interest.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"for i = 1:4:11\n    println(i)\nend","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"For loops can also be used for iterating over certain indexes to obtain values, modify them, and saving these in an alternative variable. For example:","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"a = collect(1:6)\n\nextract = [2, 3, 6]\nb = zeros(length(extract))\n\nfor x = 1:length(extract)\n    b[x] = a[extract[x]] * 2 \nend\n\nprintln(b)","category":"page"},{"location":"Basics/#While","page":"Basics","title":"While","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"In case there is not a clear range over which the iteration must take place, while loops could be used, which continue until the condition is not true is reached. The example below prints and adds 1 to the variable i until i = 9, for which the i <= 8 yields false.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"i = 1\nwhile i <= 8\n    println(i)\n    i = i + 1\nend","category":"page"},{"location":"Basics/#Flow-control","page":"Basics","title":"Flow control","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"The flow of the data through you code can also be controlled with conditional evaluations. Allowing to execute different parts of code depending on the situation.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"For example, using an if-else statement, only the even numbers can be printed by adding a if statement in the for loop that evaluates the remained by dividing a value by 2. ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"for i = 1:12\n    if rem(i,2) .== 0   \n        println(i)\n    end\nend","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Or we can even make the for loop show for each number of it is even or uneven.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"for i in [1, 100, 123, 141, 144]\n    if rem(i,2) .== 0   \n        println(\"The number $i is even\")\n    else\n        println(\"The number $i is uneven\")\n    end\nend","category":"page"},{"location":"Basics/#Functions","page":"Basics","title":"Functions","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"There might be cases where you build a code that need to be applied more than once. In these cases, both for cleanness of the code itself and convenience, the code can be put in a function. These function can then be used in the same manner as, for example, the sum() function, which comes by default with Julia. ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"For example, we could grab the code from the previous for loop and convert it to a function. ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"function EvenOrUneven(numbers)\n    for i in numbers\n        if rem(i,2) .== 0   \n            println(\"The number $i is even\")\n        else\n            println(\"The number $i is uneven\")\n        end\n    end\nend\n\nEvenOrUneven([1, 3, 6, 2, 3])","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Apart from printing results in the REPL, function can also return values with the return keyword:","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"function IsEven(numbers)\n    res = zeros(length(numbers))\n    for i = 1:length(numbers)\n        if rem(numbers[i],2) .== 0   \n            res[i] = 1\n        end\n    end\n    return res\nend\n\nout = IsEven([1, 3, 6, 2, 3])\nprintln(out)","category":"page"},{"location":"Basics/#Scope","page":"Basics","title":"Scope","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"One thing to consider when building functions is the scope of the variables. A variable can have a local or a global scope. Variables with a local scope can, for example, only be seen within a function, while global variables can be seen through out the \"file\", but not within functions. That is why these variables need to be passed down to a function, for example the variable numbers in the case below. Same as to why we need to return res to be able to used is outside the function in the global scope, which is saved in variable out. When running the code below you will notice that println(res) will actually return an error, since to the global scope this variable is not defined.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"function IsEven(numbers)\n    res = zeros(length(numbers))\n    for i = 1:length(numbers)\n        if rem(numbers[i],2) .== 0   \n            res[i] = 1\n        end\n    end\n    return res\nend\n\nout = IsEven([1, 3, 6, 2, 3])\nprintln(res)\nprintln(out)","category":"page"},{"location":"Basics/#Loading/saving-data","page":"Basics","title":"Loading/saving data","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Loading and saving of DataFrames can be done through the following lines from .csv files.","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"#loading data from csv files\ndata =  CSV.load(\"path2data\", DataFrame)\n\n#saving data to a csv file\nCSV.write(\"path2savelocation\", data)","category":"page"},{"location":"Basics/#Additional-Resources","page":"Basics","title":"Additional Resources","text":"","category":"section"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Here you can find more resources related to basic Julia usage: ","category":"page"},{"location":"Basics/","page":"Basics","title":"Basics","text":"Julia resource learning page","category":"page"},{"location":"Integration/#Numerical-Integration","page":"Numerical integration","title":"Numerical Integration","text":"","category":"section"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Numerical integration is a set of numerical methods that aim at integrating the f(x) over a defined window. Here the aim is to find the area under a curve without calculating the analytical derivative of f(x). Let's assume that the function f(x) is continuous and defined between a and b.","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nint_a^b f(x)dx \n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"The integration algorithms provide an approximation of the area under the curve for f(x). Independently from the method used, they all tend to divide the interval (i.e. a:b) into smaller chunks that could be integrated providing high enough accuracy for the true integral of the function. ","category":"page"},{"location":"Integration/#Midpoint-method","page":"Numerical integration","title":"Midpoint method","text":"","category":"section"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Midpoint method is one of the simplest numerical integration methods. The basic principal of this method is that the integral of a function can be approximated by one or more rectangles. Let's say we have the below function and we would like to integrate this between a and b. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nint_a^b (-x^2 + 50)dx \n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nx = collect(-10:0.1:10)\n\nf(x) = (- x.^2) .+ 50\n\nplot(x,f(x),label = \"f(x)\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"y = 0\")\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Let's say that the integration window is between -5 and 5. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"With the integral of assuming C = 0.","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nF(-55) = -fracx^33 + 50x + C = 416666\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Now to perform the same calculations numerically, we need to calculate the midpoint in this window as the first step. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\na = -5\nb = 5\n\nmp = mean([a,b])\n\nplot(x,f(x),label = \"f(x)\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"y = 0\")\nplot!([a,a],[0,f(mp)],label = \"a\",lc =:black)\nplot!([b,b],[0,f(mp)],label = \"b\",lc =:black)\nscatter!([mp],[f(mp)],label = \"midpoint\")\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"In the next step we need to form a rectangle from a, b, and f(midpoint), which will have a with of b - a and the length of f(midpoint). ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\na = -5\nb = 5\n\nmp = mean([a,b])\n\nplot(x,f(x),label = \"f(x)\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"y = 0\")\nplot!([a,a],[0,f(mp)],label = false,lc =:black)\nplot!([b,b],[0,f(mp)],label = false,lc =:black)\nplot!([a,b],[f(mp),f(mp)],label = \"rectangle\",lc =:black)\nscatter!([mp],[f(mp)],label = \"midpoint\")\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"In the last step, we assume that the area of this rectangle is a good approximation of the area under the f(x) within the set interval. As we remember from our high school math the area of a rectangle is calculated as: ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\narea = L times W\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"This implies the following:","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nint_a^b f(x)dx approx L times W\n\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\n\nint_a^b f(x)dx approx f(fracb+a2)(b-a)\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Let's do this integration and compare the results of the two methods. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\n\nint_mdp(f,a,b) = f(mean([a,b])) * (b - a)\n\nint_anal = 416.666\n\nint_err = int_anal -  int_mdp(f,a,b)\n\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"As you can see from the figure this single rectangle is not able to cover the full area under the curve. To solve this problem we can increase the number of rectangles within the defined window. For example we can perform the same calculations with four windows. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nn_win = 5\nn_mp = 4\n\nwins = collect(range(a,b,length = (n_win + n_mp)))   # Calculating the edges of the windows and their midpoints\nmps = wins[2:2:length(wins)]                         # Collecting only the midpoints \nedges = wins[1:2:length(wins)]\n\nf_mps = f(mps)                                       # Evaluating the midpoints \n\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\n\nplot(x,f(x),label = \"f(x)\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"y = 0\")\nscatter!(mps,f_mps,label=\"midpoints\")\nbar!(mps,f_mps,label=\"rectangles\",fillalpha = 0.3 )\n\n\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"With four windows we are getting a lot better at following the tend of the curve and we expect lower integration error compared to a single rectangle. For calculating the area under the curve with multiple rectangles, we need to multiply the evaluated midpoints by the width of the windows. Given that all the windows are equal size, we can use the first two edges for our width calculations. We also need to sum up the areas of all the rectangles to estimate the integral of the f(x). ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\n\nint_a^b f(x)dx approx sum_i=1^n f(fracx_i+x_i+12)Delta x\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nest_int = sum(f_mps .* (edges[2] - edges[1]))\n\nint_er_4 =  int_anal - est_int\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Here by increasing the number of windows from 1 to four we have drastically reduced the estimation error from -83 to -5. We can further increase the number of windows to get an acceptable accuracy. For example for the case where we have 10 or more windows, intuitively we can see that the algorithm is getting better at following the trend line in f(x). ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nn_win = 20\nn_mp = n_win - 1 \n\nwins = collect(range(a,b,length = (n_win + n_mp)))   # Calculating the edges of the windows and their midpoints\nmps = wins[2:2:length(wins)]                         # Collecting only the midpoints \nedges = wins[1:2:length(wins)]\n\nf_mps = f(mps)  \n\nplot(x,f(x),label = \"f(x)\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"y = 0\")\nscatter!(mps,f_mps,label=\"midpoints\")\nbar!(mps,f_mps,label=\"rectangles\",fillalpha = 0.3 )\n\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nest_int = sum(f_mps .* (edges[2] - edges[1]))\n\nint_er_10 =  int_anal - est_int\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"As expected the error of area estimation has become very small. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"note: Note\nThe higher is the number of windows the better is the accuracy of integration. However, in real case scenarios this may  be computationally expensive (e.g. high dimensional problems). Therefore, you need to find a balance between the number of windows and the needed accuracy. ","category":"page"},{"location":"Integration/#Trapezoid-rule","page":"Numerical integration","title":"Trapezoid rule","text":"","category":"section"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Another more accurate approach with a similar level of simplicity is trapezoid rule for numerical integration. Let's go back to our previous example (i.e. f(x)) with two windows. For the midpoint case, we generate two rectangles to predict the area under the curve. On the other hand for trapezoid rule we generate trapezoids by connecting the f(x) at the edges of the windows. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nn_win = 3                                            # hide\nn_mp = n_win - 1                                     # hide\n\nwins = collect(range(a,b,length = (n_win + n_mp)))   # hide\nmps = wins[2:2:length(wins)]                         # hide\nedges = wins[1:2:length(wins)]                       # hide\n\nf_mps = f(mps)                                       \nf_edges = f(edges)  \n\np1 = plot(x,f(x),label = \"f(x)\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"y = 0\")\nscatter!(mps,f_mps,label=\"midpoints\")\nbar!(mps,f_mps,label=\"rectangles\",fillalpha = 0.3 , legend= :bottom)\n\np2 = plot(x,f(x),label = \"f(x)\", xlabel = \"x values\", ylabel = \"f(x)\")\nplot!([-10,10],[0,0], label = \"y = 0\")\nscatter!(edges,f_edges,label=\"edges\", legend= :bottom)\nplot!([-5,-5],[0,f_edges[1]],label = false, lc =:black)\nplot!([5,5],[0,f_edges[1]],label = false, lc =:black)\nplot!([0,0],[0,f_edges[2]],label = false, lc =:black)\nplot!([-5,0],[f_edges[1],f_edges[2]],label = false, lc =:black)\nplot!([0,5],[f_edges[2],f_edges[3]],label = false, lc =:black)\n\n\nplot(p1,p2)\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"As you can see from the figure above, trapezoids are a lot better at approximating the area under the curve compared to the rectangles. In terms of math the area of a trapezoid can be calculated using the following equation.","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\n\nArea_trap = fracL+W2h\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"If we rewrite this to fit our case we will have the below equation.","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nArea_trap = fracf(x_i)+f(x_i+1)2Delta x\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"This implies that our total area approximation will become as: ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\n\nint_a^b f(x)dx approx fracDelta x2(f(x_1) + 2f(x_2) +  + 2f(x_n-1) + f(x_n))\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Now that we have the formula for approximation of area under the f(x) using trapezoid rule, we can test it for two windows. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nest_int_trap = (0.5 * (b-a)/n_mp) * (f_edges[1] + 2* f_edges[2] + f_edges[3])\n\nint_er_trap_2 =  int_anal - est_int_trap\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"using DataSci4Chem\n\nest_int = sum(f_mps .* (b-a)/n_mp)\n\nint_er_2 =  int_anal - est_int\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"note: Note\nAs you can see from the results above the trapezoid method tends to underestimate the area under the curve while the midpoint method has a tendency to overestimate the integrals. However, with enough intervals both method are able to achieve high levels of accuracy. ","category":"page"},{"location":"Integration/#Simpson's-rule","page":"Numerical integration","title":"Simpson's rule","text":"","category":"section"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"So far we have been using linear functions to perform our integration. However, as you may imagine, the linear function (i.e. f(x) = ax + b) may not be the best function to describe the trend in the objective curve. On the other hand, a function that is very well able to cover any trends is a parabola (i.e. f(x) = ax^2 + bx + c), which is the basic principal of Simpson's rule. A variation of parabola can, theoretically, cover any kind of objective function. To be able to do this we need to fit a parabola into at least three consecutive points, which will be unique. Let's write our system of equations: ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nf(x_i) = a(x_i+1 - Delta x)^2 + b(x_i+1 - Delta x) + c \nf(x_i+1) = a(x_i+1)^2 + b(x_i+1) + c \nf(x_i+2) = a(x_i+1 + Delta x)^2 + b(x_i+1 + Delta x) + c \n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Now if we solve this system of equations we will end up with the following equation:","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nint_x_i+1 - Delta x^x_i+1 + Delta x (ax^2 + bx + c)dx = sum_0^n fracDelta x3(f(x_i) + 4f(x_i+1) + f(x_i+2))\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"which will ultimately result in the below equation. ","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"\nint_x_i+1 - Delta x^x_i+1 + Delta x (ax^2 + bx + c)dx = \n\n fracDelta x3(f(x_0) + 4f(x_1) + 2f(x_2) + 4f(x_3) +  + 2f(x_n2)+4f(x_n1)+f(x_n))\n","category":"page"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"Here the pattern is that the first and the last terms stay as they are while the odd indexed terms are multiplied by four and the even ones are multiplied by two. By selecting a small enough Delta x this method is able to provide a fairly accurate estimation of the area under the curve. ","category":"page"},{"location":"Integration/#Additional-resources","page":"Numerical integration","title":"Additional resources","text":"","category":"section"},{"location":"Integration/","page":"Numerical integration","title":"Numerical integration","text":"There are additional resources for the numerical integration, for example this MIT open course. ","category":"page"},{"location":"#Data-Science-for-Chemistry","page":"Home","title":"Data Science for Chemistry","text":"","category":"section"},{"location":"#Course-content","page":"Home","title":"Course content","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This course is built for BSc of Chemistry at the University of Amsterdam (UvA). In this course, the students learn the basics of julia language programming. Additionally, they will learn how to explore multi-dimensional data (e.g. LC-MS or DOSI-IR data) from simple visualization to curve fitting. The course contains 11 lectures with dedicated pages in the documentation. In future more topics will be added to the package and thus the documentation. This package utilizes a wide range of other packages developed by others, as this is meant to facilitate the introduction of the students to programming and data science. The package is based on julia language. ","category":"page"},{"location":"","page":"Home","title":"Home","text":"Introduction to julia programming\nJulia syntax\nData visualization I\nData visualization II\nMatrix algebra & SVD\nSVD & PCA\nData manipulation\nData exploration\nNumerical root finding\nNumerical integration\nCurve fitting - Least square ","category":"page"},{"location":"","page":"Home","title":"Home","text":"For more information about the course and us, please visit us at https://emcms.info. ","category":"page"}]
}
